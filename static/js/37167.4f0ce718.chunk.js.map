{"version":3,"file":"static/js/37167.4f0ce718.chunk.js","mappings":"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","sources":["../node_modules/thirdweb/src/auth/core/create-login-message.ts","../node_modules/thirdweb/src/auth/core/sign-login-payload.ts","../node_modules/thirdweb/src/rpc/actions/eth_sendRawTransaction.ts","../node_modules/thirdweb/src/wallets/in-app/core/actions/get-enclave-user-status.ts","../node_modules/thirdweb/src/utils/random.ts","../node_modules/thirdweb/src/wallets/in-app/core/authentication/passkeys.ts","../node_modules/thirdweb/src/wallets/in-app/core/wallet/enclave-wallet.ts","../node_modules/thirdweb/src/wallets/in-app/core/actions/sign-transaction.enclave.ts","../node_modules/thirdweb/src/wallets/in-app/core/actions/sign-message.enclave.ts","../node_modules/thirdweb/src/wallets/in-app/core/actions/sign-typed-data.enclave.ts","../node_modules/thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/IframeCommunicator.ts","../node_modules/thirdweb/src/wallets/in-app/web/utils/iFrameCommunication/InAppWalletIframeCommunicator.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/abstract-login.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/base-login.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/iframe-auth.ts","../node_modules/thirdweb/src/wallets/in-app/core/actions/generate-wallet.enclave.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/auth/otp.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/iframe-wallet.ts","../node_modules/thirdweb/src/wallets/in-app/web/lib/web-connector.ts","../node_modules/thirdweb/src/wallets/in-app/core/authentication/guest.ts","../node_modules/thirdweb/src/wallets/in-app/core/authentication/siwe.ts","../node_modules/thirdweb/src/wallets/in-app/core/authentication/linkAccount.ts"],"sourcesContent":["import type { LoginPayload } from \"./types.js\";\n\n/**\n * Create an EIP-4361 & CAIP-122 compliant message to sign based on the login payload\n * @param payload - The login payload containing the necessary information.\n * @returns The generated login message.\n * @internal\n */\nexport function createLoginMessage(payload: LoginPayload): string {\n  const typeField = \"Ethereum\";\n  const header = `${payload.domain} wants you to sign in with your ${typeField} account:`;\n  let prefix = [header, payload.address].join(\"\\n\");\n  prefix = [prefix, payload.statement].join(\"\\n\\n\");\n  if (payload.statement) {\n    prefix += \"\\n\";\n  }\n\n  const suffixArray = [];\n  if (payload.uri) {\n    const uriField = `URI: ${payload.uri}`;\n    suffixArray.push(uriField);\n  }\n\n  const versionField = `Version: ${payload.version}`;\n  suffixArray.push(versionField);\n\n  if (payload.chain_id) {\n    const chainField = `Chain ID: ${payload.chain_id}` || \"1\";\n    suffixArray.push(chainField);\n  }\n\n  const nonceField = `Nonce: ${payload.nonce}`;\n  suffixArray.push(nonceField);\n\n  const issuedAtField = `Issued At: ${payload.issued_at}`;\n  suffixArray.push(issuedAtField);\n\n  const expiryField = `Expiration Time: ${payload.expiration_time}`;\n  suffixArray.push(expiryField);\n\n  if (payload.invalid_before) {\n    const invalidBeforeField = `Not Before: ${payload.invalid_before}`;\n    suffixArray.push(invalidBeforeField);\n  }\n\n  if (payload.resources) {\n    suffixArray.push(\n      [\"Resources:\", ...payload.resources.map((x) => `- ${x}`)].join(\"\\n\"),\n    );\n  }\n\n  const suffix = suffixArray.join(\"\\n\");\n  return [prefix, suffix].join(\"\\n\");\n}\n","import type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { createLoginMessage } from \"./create-login-message.js\";\nimport type { LoginPayload } from \"./types.js\";\n\n/**\n * @auth\n */\nexport type SignLoginPayloadParams = {\n  payload: LoginPayload;\n  account: Account;\n};\n\n/**\n * Signs the login payload using the provided account.\n * @param options - The options for signing the login payload.\n * @returns An object containing the signature and the payload.\n * @example\n * ```ts\n * import { signLoginPayload } from 'thirdweb/auth';\n *\n * const { signature, payload } = await signLoginPayload({\n *  payload: loginPayload,\n *  account: account,\n * });\n * ```\n * @auth\n */\nexport async function signLoginPayload(options: SignLoginPayloadParams) {\n  const { payload, account } = options;\n  const signature = await account.signMessage({\n    message: createLoginMessage(payload),\n  });\n  return {\n    signature,\n    payload,\n  };\n}\n","import type { EIP1193RequestFn, EIP1474Methods, Hex } from \"viem\";\n\n/**\n * Sends a raw transaction to the Ethereum network.\n * @param request - The EIP1193 request function.\n * @param signedTransaction - The signed transaction in hex format.\n * @returns A promise that resolves to the transaction hash.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_sendRawTransaction } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const transactionHash = await eth_sendRawTransaction(rpcRequest, \"0x...\");\n * ```\n */\nexport async function eth_sendRawTransaction(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  signedTransaction: Hex,\n) {\n  return await request({\n    method: \"eth_sendRawTransaction\",\n    params: [signedTransaction],\n  });\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { UserStatus } from \"../wallet/enclave-wallet.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\n\n/**\n * Gets the user's status from the backend.\n *\n * @internal\n */\nexport async function getUserStatus({\n  authToken,\n  client,\n  ecosystem,\n}: {\n  authToken: string;\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n}): Promise<UserStatus | undefined> {\n  const clientFetch = getClientFetch(client, ecosystem);\n  const response = await clientFetch(\n    `${getThirdwebBaseUrl(\"inAppWallet\")}/api/2024-05-05/accounts`,\n    {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-thirdweb-client-id\": client.clientId,\n        Authorization: `Bearer embedded-wallet-token:${authToken}`,\n      },\n    },\n  );\n\n  if (!response.ok) {\n    if (response.status === 401) {\n      // 401 response indicates there is no user logged in, so we return undefined\n      return undefined;\n    }\n    const result = await response.json();\n    throw new Error(`Failed to get user status: ${result.error}`);\n  }\n\n  return (await response.json()) as UserStatus;\n}\n","import { uint8ArrayToHex } from \"./encoding/hex.js\";\n\n/**\n * @internal\n */\nexport function randomBytesHex(length = 32) {\n  return uint8ArrayToHex(randomBytesBuffer(length));\n}\n\n/**\n * @internal\n */\nexport function randomBytesBuffer(length = 32) {\n  return globalThis.crypto.getRandomValues(new Uint8Array(length));\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\nimport type { ClientScopedStorage } from \"./client-scoped-storage.js\";\nimport type { AuthStoredTokenWithCookieReturnType } from \"./types.js\";\n\nfunction getVerificationPath() {\n  return `${getThirdwebBaseUrl(\n    \"inAppWallet\",\n  )}/api/2024-05-05/login/passkey/callback`;\n}\nfunction getChallengePath(type: \"sign-in\" | \"sign-up\", username?: string) {\n  return `${getThirdwebBaseUrl(\n    \"inAppWallet\",\n  )}/api/2024-05-05/login/passkey?type=${type}${\n    username ? `&username=${username}` : \"\"\n  }`;\n}\n\nexport type RegisterResult = {\n  authenticatorData: string;\n  credentialId: string;\n  clientData: string;\n  credential: {\n    publicKey: string;\n    algorithm: string;\n  };\n  origin: string;\n};\n\nexport type AuthenticateResult = {\n  credentialId: string;\n  authenticatorData: string;\n  clientData: string;\n  signature: string;\n  origin: string;\n};\n\nexport type RpInfo = { name: string; id: string };\n\nexport interface PasskeyClient {\n  register: (args: {\n    name: string;\n    challenge: string;\n    rp: RpInfo;\n  }) => Promise<RegisterResult>;\n  authenticate: (args: {\n    credentialId: string | undefined;\n    challenge: string;\n    rp: RpInfo;\n  }) => Promise<AuthenticateResult>;\n  isAvailable: () => boolean;\n}\n\nexport async function registerPasskey(options: {\n  client: ThirdwebClient;\n  passkeyClient: PasskeyClient;\n  storage?: ClientScopedStorage;\n  ecosystem?: Ecosystem;\n  username?: string;\n  rp: RpInfo;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  const generatedName = options.username ?? generateUsername(options.ecosystem);\n  // 1. request challenge from  server\n  const res = await fetchWithId(getChallengePath(\"sign-up\", generatedName));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n\n  // 2. initiate registration\n  const registration = await options.passkeyClient.register({\n    name: generatedName,\n    challenge,\n    rp: options.rp,\n  });\n\n  const customHeaders: Record<string, string> = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n\n  // 3. send the registration object to the server\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n    },\n    body: JSON.stringify({\n      type: \"sign-up\",\n      authenticatorData: registration.authenticatorData,\n      credentialId: registration.credentialId,\n      serverVerificationId: challengeData.serverVerificationId,\n      clientData: registration.clientData,\n      username: generatedName,\n      credential: {\n        publicKey: registration.credential.publicKey,\n        algorithm: registration.credential.algorithm,\n      },\n      origin: registration.origin,\n      rpId: options.rp.id,\n    }),\n  });\n  const verifData = await verifRes.json();\n\n  if (!verifData || !verifData.storedToken) {\n    throw new Error(\n      `Error verifying passkey: ${verifData.message ?? \"unknown error\"}`,\n    );\n  }\n  // 4. store the credentialId in local storage\n  await options.storage?.savePasskeyCredentialId(registration.credentialId);\n\n  // 5. returns back the IAW authentication token\n  return verifData;\n}\n\nexport async function loginWithPasskey(options: {\n  client: ThirdwebClient;\n  passkeyClient: PasskeyClient;\n  rp: RpInfo;\n  storage?: ClientScopedStorage;\n  ecosystem?: Ecosystem;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  if (!options.passkeyClient.isAvailable()) {\n    throw new Error(\"Passkeys are not available on this device\");\n  }\n  const fetchWithId = getClientFetch(options.client, options.ecosystem);\n  // 1. request challenge from  server/iframe\n  const res = await fetchWithId(getChallengePath(\"sign-in\"));\n  const challengeData = await res.json();\n  if (!challengeData.challenge) {\n    throw new Error(\"No challenge received\");\n  }\n  const challenge = challengeData.challenge;\n  // 1.2. find the user's credentialId in local storage\n  const credentialId =\n    (await options.storage?.getPasskeyCredentialId()) ?? undefined;\n\n  // 2. initiate login\n  const authentication = await options.passkeyClient.authenticate({\n    credentialId,\n    challenge,\n    rp: options.rp,\n  });\n\n  const customHeaders: Record<string, string> = {};\n  if (options.ecosystem?.partnerId) {\n    customHeaders[\"x-ecosystem-partner-id\"] = options.ecosystem.partnerId;\n  }\n  if (options.ecosystem?.id) {\n    customHeaders[\"x-ecosystem-id\"] = options.ecosystem.id;\n  }\n\n  const verifRes = await fetchWithId(getVerificationPath(), {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...customHeaders,\n    },\n    body: JSON.stringify({\n      type: \"sign-in\",\n      authenticatorData: authentication.authenticatorData,\n      credentialId: authentication.credentialId,\n      serverVerificationId: challengeData.serverVerificationId,\n      clientData: authentication.clientData,\n      signature: authentication.signature,\n      origin: authentication.origin,\n      rpId: options.rp.id,\n    }),\n  });\n\n  const verifData = await verifRes.json();\n\n  if (!verifData || !verifData.storedToken) {\n    throw new Error(\n      `Error verifying passkey: ${verifData.message ?? \"unknown error\"}`,\n    );\n  }\n\n  // 5. store the credentialId in local storage\n  await options.storage?.savePasskeyCredentialId(authentication.credentialId);\n\n  // 6. return the auth'd user type\n  return verifData;\n}\n\nfunction generateUsername(ecosystem?: Ecosystem) {\n  return `${ecosystem?.id ?? \"wallet\"}-${new Date().toISOString()}`;\n}\n","import { bytesToHex } from \"viem\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { type Hex, toHex } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parseTypedData.js\";\nimport type { Prettify } from \"../../../../utils/type-utils.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport { getUserStatus } from \"../actions/get-enclave-user-status.js\";\nimport { signMessage as signEnclaveMessage } from \"../actions/sign-message.enclave.js\";\nimport { signTransaction as signEnclaveTransaction } from \"../actions/sign-transaction.enclave.js\";\nimport { signTypedData as signEnclaveTypedData } from \"../actions/sign-typed-data.enclave.js\";\nimport type { ClientScopedStorage } from \"../authentication/client-scoped-storage.js\";\nimport type {\n  AuthDetails,\n  AuthResultAndRecoveryCode,\n  GetUser,\n} from \"../authentication/types.js\";\nimport type { Ecosystem } from \"./types.js\";\nimport type { IWebWallet } from \"./web-wallet.js\";\n\nexport type UserStatus = {\n  linkedAccounts: {\n    type: string;\n    details:\n      | { email: string; [key: string]: string }\n      | { phone: string; [key: string]: string }\n      | { address: string; [key: string]: string }\n      | { id: string; [key: string]: string };\n  }[];\n  wallets: UserWallet[];\n  id: string;\n};\n\nexport type UserWallet = {\n  address: string;\n  createdAt: string;\n  type: \"sharded\" | \"enclave\";\n};\n\nexport class EnclaveWallet implements IWebWallet {\n  private client: ThirdwebClient;\n  private ecosystem?: Ecosystem;\n  private address: string;\n  private localStorage: ClientScopedStorage;\n\n  constructor({\n    client,\n    ecosystem,\n    address,\n    storage,\n  }: Prettify<{\n    client: ThirdwebClient;\n    ecosystem?: Ecosystem;\n    address: string;\n    storage: ClientScopedStorage;\n  }>) {\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.address = address;\n    this.localStorage = storage;\n  }\n\n  /**\n   * Store the auth token for use\n   * @returns `{walletAddress: string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp(authResult: AuthResultAndRecoveryCode): Promise<void> {\n    await this.localStorage.saveAuthCookie(authResult.storedToken.cookieString);\n  }\n\n  /**\n   * Gets the current user's details\n   * @internal\n   */\n  async getUserWalletStatus(): Promise<GetUser> {\n    const token = await this.localStorage.getAuthCookie();\n    if (!token) {\n      return { status: \"Logged Out\" };\n    }\n\n    const userStatus = await getUserStatus({\n      authToken: token,\n      client: this.client,\n      ecosystem: this.ecosystem,\n    });\n\n    if (!userStatus) {\n      return { status: \"Logged Out\" };\n    }\n    const wallet = userStatus.wallets[0];\n\n    const authDetails: AuthDetails = {\n      email: userStatus.linkedAccounts.find(\n        (account) => account.details.email !== undefined,\n      )?.details.email,\n      phoneNumber: userStatus.linkedAccounts.find(\n        (account) => account.details.phone !== undefined,\n      )?.details.phone,\n      userWalletId: userStatus.id || \"\",\n      recoveryShareManagement: \"ENCLAVE\",\n    };\n\n    if (!wallet) {\n      return {\n        status: \"Logged In, Wallet Uninitialized\",\n        authDetails,\n      };\n    }\n\n    return {\n      status: \"Logged In, Wallet Initialized\",\n      walletAddress: wallet.address,\n      authDetails,\n      account: await this.getAccount(),\n    };\n  }\n\n  /**\n   * Returns an account to perform wallet operations\n   * @internal\n   */\n  async getAccount(): Promise<Account> {\n    const client = this.client;\n    const storage = this.localStorage;\n\n    const _signTransaction = async (tx: SendTransactionOption) => {\n      const rpcRequest = getRpcClient({\n        client,\n        chain: getCachedChain(tx.chainId),\n      });\n      const transaction: Record<string, Hex | number | undefined> = {\n        to: (tx.to as Hex) ?? undefined,\n        data: tx.data ? toHex(tx.data) : undefined,\n        value: tx.value ? toHex(tx.value) : undefined,\n        gas: tx.gas ? toHex(tx.gas + tx.gas / BigInt(10)) : undefined, // Add a 10% buffer to gas\n        nonce: tx.nonce\n          ? toHex(tx.nonce)\n          : toHex(\n              await import(\n                \"../../../../rpc/actions/eth_getTransactionCount.js\"\n              ).then(({ eth_getTransactionCount }) =>\n                eth_getTransactionCount(rpcRequest, {\n                  address: this.address,\n                  blockTag: \"pending\",\n                }),\n              ),\n            ),\n        chainId: toHex(tx.chainId),\n      };\n\n      if (tx.maxFeePerGas) {\n        transaction.maxFeePerGas = toHex(tx.maxFeePerGas);\n        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas\n          ? toHex(tx.maxPriorityFeePerGas)\n          : undefined;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = tx.gasPrice ? toHex(tx.gasPrice) : undefined;\n        transaction.type = 0;\n      }\n\n      return signEnclaveTransaction({\n        client,\n        storage,\n        payload: transaction,\n      });\n    };\n    return {\n      address: getAddress(this.address),\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n\n        return _signTransaction({\n          chainId: tx.chainId,\n          ...tx,\n        });\n      },\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          client,\n          chain: getCachedChain(tx.chainId),\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(\n          rpcRequest,\n          signedTx,\n        );\n        return {\n          transactionHash,\n        };\n      },\n      async signMessage({ message }) {\n        const messagePayload = (() => {\n          if (typeof message === \"string\") {\n            return { message, isRaw: false };\n          }\n          return {\n            message:\n              typeof message.raw === \"string\"\n                ? message.raw\n                : bytesToHex(message.raw),\n            isRaw: true,\n          };\n        })();\n\n        const { signature } = await signEnclaveMessage({\n          client,\n          payload: messagePayload,\n          storage,\n        });\n        return signature as Hex;\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        const { signature } = await signEnclaveTypedData({\n          client,\n          payload: parsedTypedData,\n          storage,\n        });\n\n        return signature as Hex;\n      },\n    };\n  }\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport type { Hex } from \"../../../../utils/encoding/hex.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { ClientScopedStorage } from \"../authentication/client-scoped-storage.js\";\n\nexport async function signTransaction({\n  client,\n  payload,\n  storage,\n}: {\n  client: ThirdwebClient;\n  payload: Record<string, Hex | number | undefined>;\n  storage: ClientScopedStorage;\n}) {\n  const authToken = await storage.getAuthCookie();\n  const ecosystem = storage.ecosystem;\n  const clientFetch = getClientFetch(client, ecosystem);\n\n  if (!authToken) {\n    throw new Error(\"No auth token found when signing transaction\");\n  }\n\n  const response = await clientFetch(\n    `${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/sign-transaction`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-thirdweb-client-id\": client.clientId,\n        Authorization: `Bearer embedded-wallet-token:${authToken}`,\n      },\n      body: stringify({\n        transactionPayload: payload,\n      }),\n    },\n  );\n\n  if (!response.ok) {\n    throw new Error(\"Failed to sign transaction\");\n  }\n\n  const signedTransaction = (await response.json()) as {\n    r: string;\n    s: string;\n    v: number;\n    signature: string;\n    hash: string;\n  };\n  return signedTransaction.signature as Hex;\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { ClientScopedStorage } from \"../authentication/client-scoped-storage.js\";\n\nexport async function signMessage({\n  client,\n  payload: { message, isRaw },\n  storage,\n}: {\n  client: ThirdwebClient;\n  payload: {\n    message: string;\n    isRaw: boolean;\n  };\n  storage: ClientScopedStorage;\n}) {\n  const authToken = await storage.getAuthCookie();\n  const ecosystem = storage.ecosystem;\n  const clientFetch = getClientFetch(client, ecosystem);\n\n  if (!authToken) {\n    throw new Error(\"No auth token found when signing message\");\n  }\n\n  const response = await clientFetch(\n    `${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/sign-message`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-thirdweb-client-id\": client.clientId,\n        Authorization: `Bearer embedded-wallet-token:${authToken}`,\n      },\n      body: stringify({\n        messagePayload: {\n          message,\n          isRaw,\n        },\n      }),\n    },\n  );\n\n  if (!response.ok) {\n    throw new Error(\"Failed to sign message\");\n  }\n\n  const signedMessage = (await response.json()) as {\n    r: string;\n    s: string;\n    v: number;\n    signature: string;\n    hash: string;\n  };\n  return signedMessage;\n}\n","import type { TypedData } from \"abitype\";\nimport type { TypedDataDefinition } from \"viem\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { stringify } from \"../../../../utils/json.js\";\nimport type { ClientScopedStorage } from \"../authentication/client-scoped-storage.js\";\n\nexport async function signTypedData<\n  const typedData extends TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n>({\n  client,\n  payload,\n  storage,\n}: {\n  client: ThirdwebClient;\n  payload: TypedDataDefinition<typedData, primaryType>;\n  storage: ClientScopedStorage;\n}) {\n  const authToken = await storage.getAuthCookie();\n  const ecosystem = storage.ecosystem;\n  const clientFetch = getClientFetch(client, ecosystem);\n\n  if (!authToken) {\n    throw new Error(\"No auth token found when signing typed data\");\n  }\n\n  const response = await clientFetch(\n    `${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/sign-typed-data`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-thirdweb-client-id\": client.clientId,\n        Authorization: `Bearer embedded-wallet-token:${authToken}`,\n      },\n      body: stringify({\n        ...payload,\n      }),\n    },\n  );\n\n  if (!response.ok) {\n    throw new Error(\"Failed to sign typed data\");\n  }\n\n  const signedTypedData = (await response.json()) as {\n    r: string;\n    s: string;\n    v: number;\n    signature: string;\n    hash: string;\n  };\n  return signedTypedData;\n}\n","import { sleep } from \"../../../../../utils/sleep.js\";\nimport type { ClientScopedStorage } from \"../../../../../wallets/in-app/core/authentication/client-scoped-storage.js\";\nimport type { Ecosystem } from \"../../../../../wallets/in-app/core/wallet/types.js\";\n\ntype IFrameCommunicatorProps = {\n  link: string;\n  baseUrl: string;\n  iframeId: string;\n  container?: HTMLElement;\n  onIframeInitialize?: () => void;\n  localStorage: ClientScopedStorage;\n  clientId: string;\n  ecosystem?: Ecosystem;\n};\n\nconst iframeBaseStyle = {\n  height: \"100%\",\n  width: \"100%\",\n  border: \"none\",\n  backgroundColor: \"transparent\",\n  colorScheme: \"light\",\n  position: \"fixed\",\n  top: \"0px\",\n  right: \"0px\",\n  zIndex: \"2147483646\",\n  display: \"none\",\n  pointerEvents: \"all\",\n};\n\n// Global var to help track iframe state\nconst isIframeLoaded = new Map<string, boolean>();\n\n/**\n * @internal\n */\n// biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\nexport class IframeCommunicator<T extends { [key: string]: any }> {\n  private iframe: HTMLIFrameElement;\n  private POLLING_INTERVAL_SECONDS = 1.4;\n  private iframeBaseUrl;\n  protected localStorage: ClientScopedStorage;\n  protected clientId: string;\n  protected ecosystem?: Ecosystem;\n\n  /**\n   * @internal\n   */\n  constructor({\n    link,\n    baseUrl,\n    iframeId,\n    container = document.body,\n    onIframeInitialize,\n    localStorage,\n    clientId,\n    ecosystem,\n  }: IFrameCommunicatorProps) {\n    this.localStorage = localStorage;\n    this.clientId = clientId;\n    this.ecosystem = ecosystem;\n    this.iframeBaseUrl = baseUrl;\n\n    // Creating the IFrame element for communication\n    let iframe = document.getElementById(iframeId) as HTMLIFrameElement | null;\n    const hrefLink = new URL(link);\n\n    // TODO (ew) - bring back version tracking\n    // const sdkVersion = process.env.THIRDWEB_EWS_SDK_VERSION;\n    // if (!sdkVersion) {\n    //   throw new Error(\"Missing THIRDWEB_EWS_SDK_VERSION env var\");\n    // }\n    // hrefLink.searchParams.set(\"sdkVersion\", sdkVersion);\n    if (!iframe || iframe.src !== hrefLink.href) {\n      // ! Do not update the hrefLink here or it'll cause multiple re-renders\n\n      iframe = document.createElement(\"iframe\");\n      const mergedIframeStyles = {\n        ...iframeBaseStyle,\n      };\n      Object.assign(iframe.style, mergedIframeStyles);\n      iframe.setAttribute(\"id\", iframeId);\n      iframe.setAttribute(\"fetchpriority\", \"high\");\n      container.appendChild(iframe);\n\n      iframe.src = hrefLink.href;\n\n      // iframe.setAttribute(\"data-version\", sdkVersion);\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      const onIframeLoaded = (event: MessageEvent<any>) => {\n        if (event.data.eventType === \"ewsIframeLoaded\") {\n          window.removeEventListener(\"message\", onIframeLoaded);\n          if (!iframe) {\n            console.warn(\"thirdweb iFrame not found\");\n            return;\n          }\n          this.onIframeLoadHandler(iframe, onIframeInitialize)();\n        }\n      };\n      window.addEventListener(\"message\", onIframeLoaded);\n    }\n    this.iframe = iframe;\n  }\n\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  protected async onIframeLoadedInitVariables(): Promise<Record<string, any>> {\n    return {\n      authCookie: await this.localStorage.getAuthCookie(),\n      deviceShareStored: await this.localStorage.getDeviceShare(),\n      walletUserId: await this.localStorage.getWalletUserId(),\n      clientId: this.clientId,\n      partnerId: this.ecosystem?.partnerId,\n      ecosystemId: this.ecosystem?.id,\n    };\n  }\n\n  /**\n   * @internal\n   */\n  onIframeLoadHandler(\n    iframe: HTMLIFrameElement,\n    onIframeInitialize?: () => void,\n  ) {\n    return async () => {\n      const channel = new MessageChannel();\n\n      const promise = new Promise((res, rej) => {\n        // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n        channel.port1.onmessage = (event: any) => {\n          const { data } = event;\n          channel.port1.close();\n          if (!data.success) {\n            rej(new Error(data.error));\n          }\n          isIframeLoaded.set(iframe.src, true);\n          if (onIframeInitialize) {\n            onIframeInitialize();\n          }\n          res(true);\n        };\n      });\n\n      iframe?.contentWindow?.postMessage(\n        {\n          eventType: \"initIframe\",\n          data: await this.onIframeLoadedInitVariables(),\n        },\n        this.iframeBaseUrl,\n        [channel.port2],\n      );\n\n      await promise;\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async call<ReturnData>({\n    procedureName,\n    params,\n    showIframe = false,\n  }: {\n    procedureName: keyof T;\n    params: T[keyof T];\n    showIframe?: boolean;\n  }) {\n    while (!isIframeLoaded.get(this.iframe.src)) {\n      await sleep(this.POLLING_INTERVAL_SECONDS * 1000);\n    }\n    if (showIframe) {\n      this.iframe.style.display = \"block\";\n      // magic number to let the display render before performing the animation of the modal in\n      await sleep(0.005 * 1000);\n    }\n\n    const channel = new MessageChannel();\n    const promise = new Promise<ReturnData>((res, rej) => {\n      // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n      channel.port1.onmessage = async (event: any) => {\n        const { data } = event;\n        channel.port1.close();\n        if (showIframe) {\n          // magic number to let modal fade out before hiding it\n          await sleep(0.1 * 1000);\n          this.iframe.style.display = \"none\";\n        }\n        if (!data.success) {\n          rej(new Error(data.error));\n        } else {\n          res(data.data);\n        }\n      };\n    });\n\n    this.iframe.contentWindow?.postMessage(\n      {\n        eventType: procedureName,\n        // Pass the initialization data on every request in case the iframe storage was reset (can happen in some environments such as iOS PWAs)\n        data: {\n          ...params,\n          ...(await this.onIframeLoadedInitVariables()),\n        },\n      },\n      this.iframeBaseUrl,\n      [channel.port2],\n    );\n    return promise;\n  }\n\n  /**\n   * This has to be called by any iframe that will be removed from the DOM.\n   * Use to make sure that we reset the global loaded state of the particular iframe.src\n   * @internal\n   */\n  destroy() {\n    isIframeLoaded.delete(this.iframe.src);\n  }\n}\n","import { webLocalStorage } from \"../../../../../utils/storage/webStorage.js\";\nimport { ClientScopedStorage } from \"../../../core/authentication/client-scoped-storage.js\";\nimport { IN_APP_WALLET_PATH } from \"../../../core/constants/settings.js\";\nimport type { Ecosystem } from \"../../../core/wallet/types.js\";\nimport { IframeCommunicator } from \"./IframeCommunicator.js\";\n\n/**\n * @internal\n */\nexport class InAppWalletIframeCommunicator<\n  // biome-ignore lint/suspicious/noExplicitAny: TODO: fix any\n  T extends { [key: string]: any },\n> extends IframeCommunicator<T> {\n  /**\n   * @internal\n   */\n  constructor({\n    clientId,\n    baseUrl,\n    ecosystem,\n  }: {\n    clientId: string;\n    baseUrl: string;\n    ecosystem?: Ecosystem;\n  }) {\n    super({\n      iframeId: IN_APP_WALLET_IFRAME_ID + (ecosystem?.id || \"\"),\n      link: createInAppWalletIframeLink({\n        clientId,\n        path: IN_APP_WALLET_PATH,\n        ecosystem,\n        baseUrl,\n      }).href,\n      baseUrl,\n      container: document.body,\n      localStorage: new ClientScopedStorage({\n        storage: webLocalStorage,\n        clientId,\n        ecosystem,\n      }),\n      clientId,\n      ecosystem,\n    });\n    this.clientId = clientId;\n    this.ecosystem = ecosystem;\n  }\n}\n\n// This is the URL and ID tag of the iFrame that we communicate with\n/**\n * @internal\n */\nfunction createInAppWalletIframeLink({\n  clientId,\n  baseUrl,\n  path,\n  ecosystem,\n  queryParams,\n}: {\n  clientId: string;\n  baseUrl: string;\n  path: string;\n  ecosystem?: Ecosystem;\n  queryParams?: { [key: string]: string | number };\n}) {\n  const inAppWalletUrl = new URL(`${path}`, baseUrl);\n  if (queryParams) {\n    for (const queryKey of Object.keys(queryParams)) {\n      inAppWalletUrl.searchParams.set(\n        queryKey,\n        queryParams[queryKey]?.toString() || \"\",\n      );\n    }\n  }\n  inAppWalletUrl.searchParams.set(\"clientId\", clientId);\n  if (ecosystem?.partnerId !== undefined) {\n    inAppWalletUrl.searchParams.set(\"partnerId\", ecosystem.partnerId);\n  }\n  if (ecosystem?.id !== undefined) {\n    inAppWalletUrl.searchParams.set(\"ecosystemId\", ecosystem.id);\n  }\n  return inAppWalletUrl;\n}\nconst IN_APP_WALLET_IFRAME_ID = \"thirdweb-in-app-wallet-iframe\";\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthProvider,\n  SendEmailOtpReturnType,\n} from \"../../../core/authentication/types.js\";\nimport type { Ecosystem } from \"../../../core/wallet/types.js\";\nimport type { ClientIdWithQuerierType } from \"../../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\nexport type LoginQuerierTypes = {\n  loginWithCustomAuthEndpoint: { payload: string; encryptionKey: string };\n  loginWithCustomJwt: { jwt: string; encryptionKey?: string };\n  loginWithThirdwebModal: undefined | { email: string };\n  sendThirdwebSmsLoginOtp: { phoneNumber: string };\n  sendThirdwebEmailLoginOtp: { email: string };\n  verifyThirdwebEmailLoginOtp: {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n  verifyThirdwebSmsLoginOtp: {\n    phoneNumber: string;\n    otp: string;\n    recoveryCode?: string;\n  };\n  injectDeveloperClientId: undefined;\n  getHeadlessOauthLoginLink: { authProvider: AuthProvider };\n};\n\n/**\n * @internal\n */\nexport abstract class AbstractLogin<\n  MODAL = void,\n  EMAIL_MODAL extends { email: string } = { email: string },\n  EMAIL_VERIFICATION extends { email: string; otp: string } = {\n    email: string;\n    otp: string;\n    recoveryCode?: string;\n  },\n> {\n  protected LoginQuerier: InAppWalletIframeCommunicator<LoginQuerierTypes>;\n  protected preLogin;\n  protected postLogin: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  protected client: ThirdwebClient;\n  protected baseUrl: string;\n  protected ecosystem?: Ecosystem;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * @internal\n   */\n  constructor({\n    baseUrl,\n    querier,\n    preLogin,\n    postLogin,\n    client,\n    ecosystem,\n  }: ClientIdWithQuerierType & {\n    baseUrl: string;\n    preLogin: () => Promise<void>;\n    postLogin: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n    ecosystem?: Ecosystem;\n  }) {\n    this.baseUrl = baseUrl;\n    this.LoginQuerier = querier;\n    this.preLogin = preLogin;\n    this.postLogin = postLogin;\n    this.client = client;\n    this.ecosystem = ecosystem;\n  }\n\n  abstract loginWithCustomJwt(args: {\n    jwt: string;\n    encryptionKey: string;\n  }): Promise<AuthLoginReturnType>;\n  abstract loginWithCustomAuthEndpoint(args: {\n    payload: string;\n    encryptionKey: string;\n  }): Promise<AuthLoginReturnType>;\n  abstract loginWithModal(args?: MODAL): Promise<AuthLoginReturnType>;\n  abstract loginWithIframe(args: EMAIL_MODAL): Promise<AuthLoginReturnType>;\n\n  /**\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email,\n  }: LoginQuerierTypes[\"sendThirdwebEmailLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    const result = await this.LoginQuerier.call<SendEmailOtpReturnType>({\n      procedureName: \"sendThirdwebEmailLoginOtp\",\n      params: { email },\n    });\n    return result;\n  }\n\n  /**\n   *\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber,\n  }: LoginQuerierTypes[\"sendThirdwebSmsLoginOtp\"]): Promise<SendEmailOtpReturnType> {\n    const result = await this.LoginQuerier.call<SendEmailOtpReturnType>({\n      procedureName: \"sendThirdwebSmsLoginOtp\",\n      params: { phoneNumber },\n    });\n    return result;\n  }\n\n  abstract loginWithEmailOtp(\n    args: EMAIL_VERIFICATION,\n  ): Promise<AuthLoginReturnType>;\n\n  abstract loginWithSmsOtp(args: {\n    phoneNumber: string;\n    otp: string;\n    recoveryCode?: string;\n  }): Promise<AuthLoginReturnType>;\n}\n","import type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n} from \"../../../core/authentication/types.js\";\nimport { AbstractLogin, type LoginQuerierTypes } from \"./abstract-login.js\";\n\n/**\n *\n */\nexport class BaseLogin extends AbstractLogin<\n  void,\n  { email: string },\n  { email: string; otp: string; recoveryCode?: string }\n> {\n  async authenticateWithModal(): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithThirdwebModal\",\n      params: undefined,\n      showIframe: true,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithModal(): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.authenticateWithModal();\n    return this.postLogin(result);\n  }\n\n  async authenticateWithIframe({\n    email,\n  }: {\n    email: string;\n  }): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithThirdwebModal\",\n      params: { email },\n      showIframe: true,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithIframe({\n    email,\n  }: {\n    email: string;\n  }): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n    const result = await this.authenticateWithIframe({ email });\n    return this.postLogin(result);\n  }\n\n  async authenticateWithCustomJwt({\n    encryptionKey,\n    jwt,\n  }: LoginQuerierTypes[\"loginWithCustomJwt\"]): Promise<AuthAndWalletRpcReturnType> {\n    if (!encryptionKey || encryptionKey.length === 0) {\n      throw new Error(\"Encryption key is required for custom jwt auth\");\n    }\n\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithCustomJwt\",\n      params: { encryptionKey, jwt },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithCustomJwt({\n    encryptionKey,\n    jwt,\n  }: LoginQuerierTypes[\"loginWithCustomJwt\"]): Promise<AuthLoginReturnType> {\n    if (!encryptionKey || encryptionKey.length === 0) {\n      throw new Error(\"Encryption key is required for custom jwt auth\");\n    }\n\n    await this.preLogin();\n    const result = await this.authenticateWithCustomJwt({ encryptionKey, jwt });\n    return this.postLogin(result);\n  }\n\n  async authenticateWithCustomAuthEndpoint({\n    encryptionKey,\n    payload,\n  }: LoginQuerierTypes[\"loginWithCustomAuthEndpoint\"]): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithCustomAuthEndpoint\",\n      params: { encryptionKey, payload },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithCustomAuthEndpoint({\n    encryptionKey,\n    payload,\n  }: LoginQuerierTypes[\"loginWithCustomAuthEndpoint\"]): Promise<AuthLoginReturnType> {\n    if (!encryptionKey || encryptionKey.length === 0) {\n      throw new Error(\"Encryption key is required for custom auth\");\n    }\n\n    await this.preLogin();\n    const result = await this.authenticateWithCustomAuthEndpoint({\n      encryptionKey,\n      payload,\n    });\n    return this.postLogin(result);\n  }\n\n  async authenticateWithEmailOtp({\n    email,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebEmailLoginOtp\"]): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyThirdwebEmailLoginOtp\",\n      params: { email, otp, recoveryCode },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithEmailOtp({\n    email,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebEmailLoginOtp\"]): Promise<AuthLoginReturnType> {\n    const result = await this.authenticateWithEmailOtp({\n      email,\n      otp,\n      recoveryCode,\n    });\n    return this.postLogin(result);\n  }\n\n  async authenticateWithSmsOtp({\n    phoneNumber,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebSmsLoginOtp\"]): Promise<AuthAndWalletRpcReturnType> {\n    return this.LoginQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"verifyThirdwebSmsLoginOtp\",\n      params: { phoneNumber, otp, recoveryCode },\n    });\n  }\n\n  /**\n   * @internal\n   */\n  override async loginWithSmsOtp({\n    phoneNumber,\n    otp,\n    recoveryCode,\n  }: LoginQuerierTypes[\"verifyThirdwebSmsLoginOtp\"]): Promise<AuthLoginReturnType> {\n    const result = await this.authenticateWithSmsOtp({\n      phoneNumber,\n      otp,\n      recoveryCode,\n    });\n    return this.postLogin(result);\n  }\n}\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport { generateWallet } from \"../../../core/actions/generate-wallet.enclave.js\";\nimport { getUserStatus } from \"../../../core/actions/get-enclave-user-status.js\";\nimport type { ClientScopedStorage } from \"../../../core/authentication/client-scoped-storage.js\";\nimport type {\n  AuthAndWalletRpcReturnType,\n  AuthLoginReturnType,\n  AuthStoredTokenWithCookieReturnType,\n  LogoutReturnType,\n  SendEmailOtpReturnType,\n} from \"../../../core/authentication/types.js\";\nimport type { Ecosystem } from \"../../../core/wallet/types.js\";\nimport type { ClientIdWithQuerierType } from \"../../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { BaseLogin } from \"./base-login.js\";\n\nexport type AuthQuerierTypes = {\n  logout: undefined;\n  initIframe: {\n    partnerId?: string;\n    ecosystemId?: string;\n    clientId: string;\n    authCookie: string;\n    walletUserId: string;\n    deviceShareStored: string | null;\n  };\n  loginWithStoredTokenDetails: {\n    storedToken: AuthStoredTokenWithCookieReturnType[\"storedToken\"];\n    recoveryCode?: string;\n  };\n  migrateFromShardToEnclave: {\n    storedToken: AuthStoredTokenWithCookieReturnType[\"storedToken\"];\n  };\n};\n\n/**\n *\n */\nexport class Auth {\n  protected client: ThirdwebClient;\n  protected ecosystem?: Ecosystem;\n  protected AuthQuerier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n  protected localStorage: ClientScopedStorage;\n  protected onAuthSuccess: (\n    authResults: AuthAndWalletRpcReturnType,\n  ) => Promise<AuthLoginReturnType>;\n  private BaseLogin: BaseLogin;\n\n  /**\n   * Used to manage the user's auth states. This should not be instantiated directly.\n   * @internal\n   */\n  constructor({\n    client,\n    querier,\n    onAuthSuccess,\n    ecosystem,\n    baseUrl,\n    localStorage,\n  }: ClientIdWithQuerierType & {\n    baseUrl: string;\n    ecosystem?: Ecosystem;\n    onAuthSuccess: (\n      authDetails: AuthAndWalletRpcReturnType,\n    ) => Promise<AuthLoginReturnType>;\n    localStorage: ClientScopedStorage;\n  }) {\n    this.client = client;\n    this.ecosystem = ecosystem;\n\n    this.AuthQuerier = querier;\n    this.localStorage = localStorage;\n    this.onAuthSuccess = onAuthSuccess;\n    this.BaseLogin = new BaseLogin({\n      postLogin: async (result) => {\n        return this.postLogin(result);\n      },\n      preLogin: async () => {\n        await this.preLogin();\n      },\n      ecosystem,\n      querier: querier,\n      client,\n      baseUrl,\n    });\n  }\n\n  private async preLogin() {\n    await this.logout();\n  }\n\n  private async postLogin({\n    storedToken,\n    walletDetails,\n  }: AuthAndWalletRpcReturnType): Promise<AuthLoginReturnType> {\n    if (storedToken.shouldStoreCookieString) {\n      await this.localStorage.saveAuthCookie(storedToken.cookieString);\n    }\n    const initializedUser = await this.onAuthSuccess({\n      storedToken,\n      walletDetails,\n    });\n    return initializedUser;\n  }\n\n  async loginWithAuthToken(\n    authToken: AuthStoredTokenWithCookieReturnType,\n    recoveryCode?: string,\n  ): Promise<AuthLoginReturnType> {\n    await this.preLogin();\n\n    const user = await getUserStatus({\n      authToken: authToken.storedToken.cookieString,\n      client: this.client,\n      ecosystem: this.ecosystem,\n    });\n    if (!user) {\n      throw new Error(\"Cannot login, no user found for auth token\");\n    }\n\n    // If they're already an enclave wallet, proceed to login\n    if (user.wallets.length > 0 && user.wallets[0]?.type === \"enclave\") {\n      return this.postLogin({\n        storedToken: authToken.storedToken,\n        walletDetails: {\n          walletAddress: user.wallets[0].address,\n        },\n      });\n    }\n\n    if (user.wallets.length === 0 && this.ecosystem) {\n      // If this is a new ecosystem wallet without an enclave yet, we'll generate an enclave\n      const result = await generateWallet({\n        authToken: authToken.storedToken.cookieString,\n        client: this.client,\n        ecosystem: this.ecosystem,\n      });\n      return this.postLogin({\n        storedToken: authToken.storedToken,\n        walletDetails: {\n          walletAddress: result.address,\n        },\n      });\n    }\n\n    // If this is an existing sharded wallet or in-app wallet, we'll login with the sharded wallet\n    const result = await this.AuthQuerier.call<AuthAndWalletRpcReturnType>({\n      procedureName: \"loginWithStoredTokenDetails\",\n      params: {\n        storedToken: authToken.storedToken,\n        recoveryCode,\n      },\n    });\n    return this.postLogin(result);\n  }\n\n  /**\n   * Used to log the user into their thirdweb wallet on your platform via a myriad of auth providers\n   * @example\n   * ```typescript\n   * const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"YOUR_CLIENT_ID\", chain: \"Polygon\"})\n   * try {\n   *   const user = await thirdwebInAppWallet.auth.loginWithModal();\n   *   // user is now logged in\n   * } catch (e) {\n   *   // User closed modal or something else went wrong during the authentication process\n   *   console.error(e)\n   * }\n   * ```\n   * @returns `{{user: InitializedUser}}` An InitializedUser object.\n   */\n  async loginWithModal(): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithModal();\n  }\n  async authenticateWithModal(): Promise<AuthAndWalletRpcReturnType> {\n    return this.BaseLogin.authenticateWithModal();\n  }\n\n  /**\n   * Used to log the user into their thirdweb wallet using email OTP\n   * @example\n   * ```typescript\n   *  // Basic Flow\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  try {\n   *    // prompts user to enter the code they received\n   *    const user = await thirdwebInAppWallet.auth.loginWithThirdwebEmailOtp({ email : \"you@example.com\" });\n   *    // user is now logged in\n   *  } catch (e) {\n   *    // User closed the OTP modal or something else went wrong during the authentication process\n   *    console.error(e)\n   *  }\n   * ```\n   * @param args - args.email: We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{user: InitializedUser}}` An InitializedUser object. See {@link InAppWalletSdk.getUser} for more\n   */\n  async loginWithIframe(\n    args: Parameters<BaseLogin[\"loginWithIframe\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithIframe(args);\n  }\n  async authenticateWithIframe(\n    args: Parameters<BaseLogin[\"authenticateWithIframe\"]>[0],\n  ): Promise<AuthAndWalletRpcReturnType> {\n    return this.BaseLogin.authenticateWithIframe(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithCustomJwt(\n    args: Parameters<BaseLogin[\"loginWithCustomJwt\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithCustomJwt(args);\n  }\n  async authenticateWithCustomJwt(\n    args: Parameters<BaseLogin[\"authenticateWithCustomJwt\"]>[0],\n  ): Promise<AuthAndWalletRpcReturnType> {\n    return this.BaseLogin.authenticateWithCustomJwt(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithCustomAuthEndpoint(\n    args: Parameters<BaseLogin[\"loginWithCustomAuthEndpoint\"]>[0],\n  ): Promise<AuthLoginReturnType> {\n    return this.BaseLogin.loginWithCustomAuthEndpoint(args);\n  }\n  async authenticateWithCustomAuthEndpoint(\n    args: Parameters<BaseLogin[\"authenticateWithCustomAuthEndpoint\"]>[0],\n  ): Promise<AuthAndWalletRpcReturnType> {\n    return this.BaseLogin.authenticateWithCustomAuthEndpoint(args);\n  }\n\n  /**\n   * A headless way to send the users at the passed email an OTP code.\n   * You need to then call {@link Auth.loginWithEmailOtp} in order to complete the login process\n   * @example\n   * @param param0.email\n   * ```typescript\n   *  const thirdwebInAppWallet = new InAppWalletSdk({clientId: \"\", chain: \"Polygon\"});\n   *  // sends user an OTP code\n   * try {\n   *    await thirdwebInAppWallet.auth.sendEmailLoginOtp({ email : \"you@example.com\" });\n   * } catch(e) {\n   *    // Error Sending user's email an OTP code\n   *    console.error(e);\n   * }\n   *\n   * // Then when your user is ready to verify their OTP\n   * try {\n   *    const user = await thirdwebInAppWallet.auth.verifyEmailLoginOtp({ email: \"you@example.com\", otp: \"6-DIGIT_CODE_HERE\" });\n   * } catch(e) {\n   *    // Error verifying the OTP code\n   *    console.error(e)\n   * }\n   * ```\n   * @param param0 - param0.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * @returns `{{ isNewUser: boolean }}` IsNewUser indicates if the user is a new user to your platform\n   * @internal\n   */\n  async sendEmailLoginOtp({\n    email,\n  }: Parameters<\n    BaseLogin[\"sendEmailLoginOtp\"]\n  >[0]): Promise<SendEmailOtpReturnType> {\n    return this.BaseLogin.sendEmailLoginOtp({\n      email,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async sendSmsLoginOtp({\n    phoneNumber,\n  }: Parameters<\n    BaseLogin[\"sendSmsLoginOtp\"]\n  >[0]): Promise<SendEmailOtpReturnType> {\n    return this.BaseLogin.sendSmsLoginOtp({\n      phoneNumber,\n    });\n  }\n\n  /**\n   * Used to verify the otp that the user receives from thirdweb\n   *\n   * See {@link Auth.sendEmailLoginOtp} for how the headless call flow looks like. Simply swap out the calls to `loginWithThirdwebEmailOtp` with `verifyThirdwebEmailLoginOtp`\n   * @param args - props.email We will send the email an OTP that needs to be entered in order for them to be logged in.\n   * props.otp The code that the user received in their email\n   * @returns `{{user: InitializedUser}}` An InitializedUser object containing the user's status, wallet, authDetails, and more\n   * @internal\n   */\n  async loginWithEmailOtp(args: Parameters<BaseLogin[\"loginWithEmailOtp\"]>[0]) {\n    await this.preLogin();\n    return this.BaseLogin.loginWithEmailOtp(args);\n  }\n  async authenticateWithEmailOtp(\n    args: Parameters<BaseLogin[\"authenticateWithEmailOtp\"]>[0],\n  ) {\n    return this.BaseLogin.authenticateWithEmailOtp(args);\n  }\n\n  /**\n   * @internal\n   */\n  async loginWithSmsOtp(args: Parameters<BaseLogin[\"loginWithSmsOtp\"]>[0]) {\n    await this.preLogin();\n    return this.BaseLogin.loginWithSmsOtp(args);\n  }\n  async authenticateWithSmsOtp(\n    args: Parameters<BaseLogin[\"authenticateWithSmsOtp\"]>[0],\n  ) {\n    return this.BaseLogin.authenticateWithSmsOtp(args);\n  }\n\n  /**\n   * Logs any existing user out of their wallet.\n   * @returns `{{success: boolean}}` true if a user is successfully logged out. false if there's no user currently logged in.\n   * @internal\n   */\n  async logout(): Promise<LogoutReturnType> {\n    if (this.AuthQuerier) {\n      await this.AuthQuerier.call<LogoutReturnType>({\n        procedureName: \"logout\",\n        params: undefined,\n      });\n    }\n\n    const isRemoveAuthCookie = await this.localStorage.removeAuthCookie();\n    const isRemoveUserId = await this.localStorage.removeWalletUserId();\n\n    return {\n      success: isRemoveAuthCookie || isRemoveUserId,\n    };\n  }\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { UserWallet } from \"../wallet/enclave-wallet.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\n\n/**\n * Generate a new enclave wallet using an auth token\n * @internal\n */\nexport async function generateWallet({\n  authToken,\n  client,\n  ecosystem,\n}: {\n  client: ThirdwebClient;\n  ecosystem: Ecosystem;\n  authToken: string;\n}) {\n  const clientFetch = getClientFetch(client, ecosystem);\n  const response = await clientFetch(\n    `${getThirdwebBaseUrl(\"inAppWallet\")}/api/v1/enclave-wallet/generate`,\n    {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"x-thirdweb-client-id\": client.clientId,\n        Authorization: `Bearer embedded-wallet-token:${authToken}`,\n      },\n    },\n  );\n\n  if (!response.ok) {\n    throw new Error(\"Failed to generate wallet\");\n  }\n\n  const { wallet } = (await response.json()) as {\n    wallet: UserWallet;\n  };\n\n  return wallet;\n}\n","import type { ThirdwebClient } from \"../../../../../client/client.js\";\nimport {\n  getLoginCallbackUrl,\n  getLoginUrl,\n} from \"../../../core/authentication/getLoginPath.js\";\nimport type {\n  AuthStoredTokenWithCookieReturnType,\n  MultiStepAuthArgsType,\n  PreAuthArgsType,\n} from \"../../../core/authentication/types.js\";\nimport type { Ecosystem } from \"../../../core/wallet/types.js\";\n\n/**\n * @internal\n */\nexport const sendOtp = async (args: PreAuthArgsType): Promise<void> => {\n  const { client, ecosystem } = args;\n  const url = getLoginUrl({ client, ecosystem, authOption: args.strategy });\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    \"x-client-id\": client.clientId,\n  };\n\n  if (ecosystem?.id) {\n    headers[\"x-ecosystem-id\"] = ecosystem.id;\n  }\n\n  if (ecosystem?.partnerId) {\n    headers[\"x-ecosystem-partner-id\"] = ecosystem.partnerId;\n  }\n\n  const body = (() => {\n    switch (args.strategy) {\n      case \"email\":\n        return {\n          email: args.email,\n        };\n      case \"phone\":\n        return {\n          phone: args.phoneNumber,\n        };\n    }\n  })();\n\n  const response = await fetch(url, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    throw new Error(\"Failed to send verification code\");\n  }\n\n  return await response.json();\n};\n\n/**\n * @internal\n */\nexport const verifyOtp = async (\n  args: MultiStepAuthArgsType & {\n    client: ThirdwebClient;\n    ecosystem?: Ecosystem;\n  },\n): Promise<AuthStoredTokenWithCookieReturnType> => {\n  const { client, ecosystem } = args;\n  const url = getLoginCallbackUrl({\n    authOption: args.strategy,\n    client: args.client,\n    ecosystem: args.ecosystem,\n  });\n\n  const headers: Record<string, string> = {\n    \"Content-Type\": \"application/json\",\n    \"x-client-id\": client.clientId,\n  };\n\n  if (ecosystem?.id) {\n    headers[\"x-ecosystem-id\"] = ecosystem.id;\n  }\n\n  if (ecosystem?.partnerId) {\n    headers[\"x-ecosystem-partner-id\"] = ecosystem.partnerId;\n  }\n\n  const body = (() => {\n    switch (args.strategy) {\n      case \"email\":\n        return {\n          email: args.email,\n          code: args.verificationCode,\n        };\n      case \"phone\":\n        return {\n          phone: args.phoneNumber,\n          code: args.verificationCode,\n        };\n    }\n  })();\n\n  const response = await fetch(url, {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    throw new Error(\"Failed to verify verification code\");\n  }\n\n  return await response.json();\n};\n","import type * as ethers5 from \"ethers5\";\nimport type { TypedDataDefinition } from \"viem\";\nimport { getCachedChain } from \"../../../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../../rpc/rpc.js\";\nimport { getAddress } from \"../../../../utils/address.js\";\nimport { getThirdwebDomains } from \"../../../../utils/domains.js\";\nimport { type Hex, hexToString } from \"../../../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../../../utils/signatures/helpers/parseTypedData.js\";\nimport type { Prettify } from \"../../../../utils/type-utils.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n} from \"../../../interfaces/wallet.js\";\nimport type { ClientScopedStorage } from \"../../core/authentication/client-scoped-storage.js\";\nimport type {\n  AuthResultAndRecoveryCode,\n  GetUser,\n  GetUserWalletStatusRpcReturnType,\n} from \"../../core/authentication/types.js\";\nimport type { Ecosystem } from \"../../core/wallet/types.js\";\nimport type { IWebWallet } from \"../../core/wallet/web-wallet.js\";\nimport type {\n  ClientIdWithQuerierType,\n  GetAddressReturnType,\n  SignMessageReturnType,\n  SignTransactionReturnType,\n  SignedTypedDataReturnType,\n} from \"../types.js\";\nimport type { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\n\ntype WalletManagementTypes = {\n  createWallet: undefined;\n  setUpNewDevice: undefined;\n  getUserStatus: undefined;\n};\ntype WalletManagementUiTypes = {\n  createWalletUi: undefined;\n  setUpNewDeviceUi: undefined;\n};\n\ntype SignerProcedureTypes = {\n  getAddress: undefined;\n  signMessage: {\n    message: string | Hex;\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  signTransaction: {\n    transaction: ethers5.ethers.providers.TransactionRequest;\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  signTypedDataV4: {\n    domain: TypedDataDefinition[\"domain\"];\n    types: TypedDataDefinition[\"types\"];\n    message: TypedDataDefinition[\"message\"];\n    chainId: number;\n    rpcEndpoint?: string;\n    partnerId?: string;\n  };\n  //connect: { provider: Provider };\n};\n\n/**\n *\n */\nexport class IFrameWallet implements IWebWallet {\n  public client: ThirdwebClient;\n  public ecosystem?: Ecosystem;\n  protected walletManagerQuerier: InAppWalletIframeCommunicator<\n    WalletManagementTypes & WalletManagementUiTypes\n  >;\n  protected localStorage: ClientScopedStorage;\n\n  /**\n   * Not meant to be initialized directly. Call {@link initializeUser} to get an instance\n   * @internal\n   */\n  constructor({\n    client,\n    ecosystem,\n    querier,\n    localStorage,\n  }: Prettify<\n    ClientIdWithQuerierType & {\n      ecosystem?: Ecosystem;\n      localStorage: ClientScopedStorage;\n    }\n  >) {\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.walletManagerQuerier = querier;\n    this.localStorage = localStorage;\n  }\n\n  /**\n   * Used to set-up the user device in the case that they are using incognito\n   * @returns `{walletAddress : string }` The user's wallet details\n   * @internal\n   */\n  async postWalletSetUp(authResult: AuthResultAndRecoveryCode): Promise<void> {\n    if (authResult.deviceShareStored) {\n      await this.localStorage.saveDeviceShare(\n        authResult.deviceShareStored,\n        authResult.storedToken.authDetails.userWalletId,\n      );\n    }\n  }\n\n  /**\n   * Gets the various status states of the user\n   * @example\n   * ```typescript\n   *  const userStatus = await Paper.getUserWalletStatus();\n   *  switch (userStatus.status) {\n   *  case UserWalletStatus.LOGGED_OUT: {\n   *    // User is logged out, call one of the auth methods on Paper.auth to authenticate the user\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_UNINITIALIZED: {\n   *    // User is logged in, but does not have a wallet associated with it\n   *    // you also have access to the user's details\n   *    userStatus.user.authDetails;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_NEW_DEVICE: {\n   *    // User is logged in and created a wallet already, but is missing the device shard\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    break;\n   *  }\n   *  case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *    // user is logged in and wallet is all set up.\n   *    // You have access to:\n   *    userStatus.user.authDetails;\n   *    userStatus.user.walletAddress;\n   *    userStatus.user.wallet;\n   *    break;\n   *  }\n   *}\n   *```\n   * @returns `{GetUserWalletStatusFnReturnType}` an object to containing various information on the user statuses\n   * @internal\n   */\n  async getUserWalletStatus(): Promise<GetUser> {\n    const userStatus =\n      await this.walletManagerQuerier.call<GetUserWalletStatusRpcReturnType>({\n        procedureName: \"getUserStatus\",\n        params: undefined,\n      });\n    if (userStatus.status === \"Logged In, Wallet Initialized\") {\n      return {\n        status: \"Logged In, Wallet Initialized\",\n        ...userStatus.user,\n        account: await this.getAccount(),\n      };\n    }\n    if (userStatus.status === \"Logged In, New Device\") {\n      return {\n        status: \"Logged In, New Device\",\n        ...userStatus.user,\n      };\n    }\n    if (userStatus.status === \"Logged In, Wallet Uninitialized\") {\n      return {\n        status: \"Logged In, Wallet Uninitialized\",\n        ...userStatus.user,\n      };\n    }\n    // Logged out\n    return { status: userStatus.status };\n  }\n\n  /**\n   * Returns an account that communicates with the iFrame for signing operations\n   * @internal\n   */\n  async getAccount(): Promise<Account> {\n    const querier = this\n      .walletManagerQuerier as unknown as InAppWalletIframeCommunicator<SignerProcedureTypes>;\n    const client = this.client;\n    const partnerId = this.ecosystem?.partnerId;\n\n    const { address } = await querier.call<GetAddressReturnType>({\n      procedureName: \"getAddress\",\n      params: undefined,\n    });\n    const _signTransaction = async (tx: SendTransactionOption) => {\n      // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n      const transaction: Record<string, any> = {\n        to: tx.to ?? undefined,\n        data: tx.data,\n        value: tx.value,\n        gasLimit: tx.gas,\n        nonce: tx.nonce,\n        chainId: tx.chainId,\n      };\n\n      if (tx.maxFeePerGas) {\n        // ethers (in the iframe) rejects any type 0 trasaction with unknown keys\n        // TODO remove this once iframe is upgraded to v5\n        transaction.accessList = tx.accessList;\n        transaction.maxFeePerGas = tx.maxFeePerGas;\n        transaction.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;\n        transaction.type = 2;\n      } else {\n        transaction.gasPrice = tx.gasPrice;\n        transaction.type = 0;\n      }\n      const RPC_URL = getThirdwebDomains().rpc;\n      const { signedTransaction } =\n        await querier.call<SignTransactionReturnType>({\n          procedureName: \"signTransaction\",\n          params: {\n            transaction,\n            chainId: tx.chainId,\n            partnerId,\n            rpcEndpoint: `https://${tx.chainId}.${RPC_URL}`, // TODO (ew) shouldnt be needed\n          },\n        });\n      return signedTransaction as Hex;\n    };\n    return {\n      address: getAddress(address),\n      async signTransaction(tx) {\n        if (!tx.chainId) {\n          throw new Error(\"chainId required in tx to sign\");\n        }\n        return _signTransaction({\n          ...tx,\n          chainId: tx.chainId,\n        });\n      },\n      async sendTransaction(tx) {\n        const rpcRequest = getRpcClient({\n          client,\n          chain: getCachedChain(tx.chainId),\n        });\n        const signedTx = await _signTransaction(tx);\n        const transactionHash = await eth_sendRawTransaction(\n          rpcRequest,\n          signedTx,\n        );\n        return {\n          transactionHash,\n        };\n      },\n      async signMessage({ message }) {\n        // in-app wallets use ethers to sign messages, which always expects a string (or bytes maybe but string is safest)\n        const messageDecoded = (() => {\n          if (typeof message === \"string\") {\n            return message;\n          }\n          if (message.raw instanceof Uint8Array) {\n            return message.raw;\n          }\n          return hexToString(message.raw);\n        })();\n\n        const { signedMessage } = await querier.call<SignMessageReturnType>({\n          procedureName: \"signMessage\",\n          params: {\n            // biome-ignore lint/suspicious/noExplicitAny: ethers tx transformation\n            message: messageDecoded as any, // needs bytes or string\n            partnerId,\n            chainId: 1, // TODO check if we need this\n          },\n        });\n        return signedMessage as Hex;\n      },\n      async signTypedData(_typedData) {\n        const parsedTypedData = parseTypedData(_typedData);\n        // deleting EIP712 Domain as it results in ambiguous primary type on some cases\n        // this happens when going from viem to ethers via the iframe\n        if (parsedTypedData.types?.EIP712Domain) {\n          parsedTypedData.types.EIP712Domain = undefined;\n        }\n        const domain = parsedTypedData.domain as TypedDataDefinition[\"domain\"];\n        const chainId = domain?.chainId;\n        const verifyingContract = domain?.verifyingContract\n          ? { verifyingContract: domain?.verifyingContract }\n          : {};\n        const domainData = {\n          ...verifyingContract,\n          name: domain?.name,\n          version: domain?.version,\n        };\n        // chain id can't be included if it wasn't explicitly specified\n        if (chainId) {\n          (domainData as Record<string, unknown>).chainId = chainId;\n        }\n\n        const RPC_URL = getThirdwebDomains().rpc;\n        const { signedTypedData } =\n          await querier.call<SignedTypedDataReturnType>({\n            procedureName: \"signTypedDataV4\",\n            params: {\n              domain: domainData,\n              types:\n                parsedTypedData.types as SignerProcedureTypes[\"signTypedDataV4\"][\"types\"],\n              message:\n                parsedTypedData.message as SignerProcedureTypes[\"signTypedDataV4\"][\"message\"],\n              chainId: chainId || 1,\n              partnerId,\n              rpcEndpoint: `https://${chainId}.${RPC_URL}`, // TODO (ew) shouldnt be needed\n            },\n          });\n        return signedTypedData as Hex;\n      },\n    };\n  }\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { webLocalStorage } from \"../../../../utils/storage/webStorage.js\";\nimport type { SocialAuthOption } from \"../../../../wallets/types.js\";\nimport type { Account } from \"../../../interfaces/wallet.js\";\nimport { getUserStatus } from \"../../core/actions/get-enclave-user-status.js\";\nimport { ClientScopedStorage } from \"../../core/authentication/client-scoped-storage.js\";\nimport { guestAuthenticate } from \"../../core/authentication/guest.js\";\nimport {\n  getLinkedProfilesInternal,\n  linkAccount,\n} from \"../../core/authentication/linkAccount.js\";\nimport {\n  loginWithPasskey,\n  registerPasskey,\n} from \"../../core/authentication/passkeys.js\";\nimport { siweAuthenticate } from \"../../core/authentication/siwe.js\";\nimport type {\n  AuthArgsType,\n  AuthLoginReturnType,\n  AuthStoredTokenWithCookieReturnType,\n  GetUser,\n  LogoutReturnType,\n  MultiStepAuthArgsType,\n  MultiStepAuthProviderType,\n  SingleStepAuthArgsType,\n} from \"../../core/authentication/types.js\";\nimport type { InAppConnector } from \"../../core/interfaces/connector.js\";\nimport { EnclaveWallet } from \"../../core/wallet/enclave-wallet.js\";\nimport type { Ecosystem } from \"../../core/wallet/types.js\";\nimport type { IWebWallet } from \"../../core/wallet/web-wallet.js\";\nimport type { InAppWalletConstructorType } from \"../types.js\";\nimport { InAppWalletIframeCommunicator } from \"../utils/iFrameCommunication/InAppWalletIframeCommunicator.js\";\nimport { Auth, type AuthQuerierTypes } from \"./auth/iframe-auth.js\";\nimport { loginWithOauth, loginWithOauthRedirect } from \"./auth/oauth.js\";\nimport { sendOtp, verifyOtp } from \"./auth/otp.js\";\nimport { IFrameWallet } from \"./iframe-wallet.js\";\n\n/**\n * @internal\n */\nexport class InAppWebConnector implements InAppConnector {\n  private client: ThirdwebClient;\n  private ecosystem?: Ecosystem;\n  private querier: InAppWalletIframeCommunicator<AuthQuerierTypes>;\n  private storage: ClientScopedStorage;\n\n  private wallet?: IWebWallet;\n  /**\n   * Used to manage the Auth state of the user.\n   */\n  auth: Auth;\n  private passkeyDomain?: string;\n\n  private isClientIdLegacyPaper(clientId: string): boolean {\n    if (clientId.indexOf(\"-\") > 0 && clientId.length === 36) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @example\n   * `const thirdwebInAppWallet = new InAppWalletSdk({ clientId: \"\", chain: \"Goerli\" });`\n   * @internal\n   */\n  constructor({\n    client,\n    onAuthSuccess,\n    ecosystem,\n    passkeyDomain,\n  }: InAppWalletConstructorType) {\n    if (this.isClientIdLegacyPaper(client.clientId)) {\n      throw new Error(\n        \"You are using a legacy clientId. Please use the clientId found on the thirdweb dashboard settings page\",\n      );\n    }\n    const baseUrl = getThirdwebBaseUrl(\"inAppWallet\");\n    this.client = client;\n    this.ecosystem = ecosystem;\n    this.passkeyDomain = passkeyDomain;\n    this.storage = new ClientScopedStorage({\n      storage: webLocalStorage,\n      clientId: client.clientId,\n      ecosystem: ecosystem,\n    });\n    this.querier = new InAppWalletIframeCommunicator({\n      clientId: client.clientId,\n      ecosystem,\n      baseUrl,\n    });\n\n    this.auth = new Auth({\n      client,\n      querier: this.querier,\n      baseUrl,\n      localStorage: this.storage,\n      ecosystem,\n      onAuthSuccess: async (authResult) => {\n        onAuthSuccess?.(authResult);\n\n        if (\n          this.ecosystem &&\n          authResult.storedToken.authDetails.walletType === \"sharded\"\n        ) {\n          // If this is an existing sharded ecosystem wallet, we'll need to migrate\n          const result = await this.querier.call<boolean>({\n            procedureName: \"migrateFromShardToEnclave\",\n            params: {\n              storedToken: authResult.storedToken,\n            },\n          });\n          if (!result) {\n            throw new Error(\"Failed to migrate from sharded to enclave wallet\");\n          }\n        }\n\n        await this.initializeWallet(authResult.storedToken.cookieString);\n\n        if (!this.wallet) {\n          throw new Error(\"Failed to initialize wallet\");\n        }\n\n        const deviceShareStored =\n          \"deviceShareStored\" in authResult.walletDetails\n            ? authResult.walletDetails.deviceShareStored\n            : undefined;\n\n        await this.wallet.postWalletSetUp({\n          storedToken: authResult.storedToken,\n          deviceShareStored,\n        });\n\n        if (authResult.storedToken.authDetails.walletType !== \"enclave\") {\n          await this.querier.call({\n            procedureName: \"initIframe\",\n            params: {\n              partnerId: ecosystem?.partnerId,\n              ecosystemId: ecosystem?.id,\n              clientId: this.client.clientId,\n              // For enclave wallets we won't have a device share\n              deviceShareStored:\n                \"deviceShareStored\" in authResult.walletDetails\n                  ? authResult.walletDetails.deviceShareStored\n                  : null,\n              walletUserId: authResult.storedToken.authDetails.userWalletId,\n              authCookie: authResult.storedToken.cookieString,\n            },\n          });\n        }\n\n        return {\n          user: {\n            status: \"Logged In, Wallet Initialized\",\n            authDetails: authResult.storedToken.authDetails,\n            account: await this.wallet.getAccount(),\n            walletAddress: authResult.walletDetails.walletAddress,\n          },\n        };\n      },\n    });\n  }\n\n  async initializeWallet(authToken?: string) {\n    const storedAuthToken = await this.storage.getAuthCookie();\n    if (!authToken && storedAuthToken === null) {\n      throw new Error(\n        \"No auth token provided and no stored auth token found to initialize the wallet\",\n      );\n    }\n\n    const user = await getUserStatus({\n      authToken: authToken || (storedAuthToken as string),\n      client: this.client,\n      ecosystem: this.ecosystem,\n    });\n    if (!user) {\n      throw new Error(\"Cannot initialize wallet, no user logged in\");\n    }\n    if (user.wallets.length === 0) {\n      throw new Error(\n        \"Cannot initialize wallet, this user does not have a wallet generated yet\",\n      );\n    }\n\n    if (user.wallets[0]?.type === \"enclave\") {\n      this.wallet = new EnclaveWallet({\n        client: this.client,\n        ecosystem: this.ecosystem,\n        address: user.wallets[0].address,\n        storage: this.storage,\n      });\n      return;\n    }\n\n    this.wallet = new IFrameWallet({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      querier: this.querier,\n      localStorage: this.storage,\n    });\n  }\n\n  /**\n   * Gets the user if they're logged in\n   * @example\n   * ```js\n   *  const user = await thirdwebInAppWallet.getUser();\n   *  switch (user.status) {\n   *     case UserWalletStatus.LOGGED_OUT: {\n   *       // User is logged out, call one of the auth methods on thirdwebInAppWallet.auth to authenticate the user\n   *       break;\n   *     }\n   *     case UserWalletStatus.LOGGED_IN_WALLET_INITIALIZED: {\n   *       // user is logged in and wallet is all set up.\n   *       // You have access to:\n   *       user.status;\n   *       user.authDetails;\n   *       user.walletAddress;\n   *       user.wallet;\n   *       break;\n   *     }\n   * }\n   * ```\n   * @returns GetUser - an object to containing various information on the user statuses\n   */\n  async getUser(): Promise<GetUser> {\n    // If we don't have a wallet yet we'll create one\n    if (!this.wallet) {\n      const localAuthToken = await this.storage.getAuthCookie();\n      if (!localAuthToken) {\n        return { status: \"Logged Out\" };\n      }\n      await this.initializeWallet(localAuthToken);\n    }\n    if (!this.wallet) {\n      throw new Error(\"Wallet not initialized\");\n    }\n    return await this.wallet.getUserWalletStatus();\n  }\n\n  getAccount(): Promise<Account> {\n    if (!this.wallet) {\n      throw new Error(\"Wallet not initialized\");\n    }\n    return this.wallet.getAccount();\n  }\n\n  async preAuthenticate(args: MultiStepAuthProviderType): Promise<void> {\n    return sendOtp({\n      ...args,\n      client: this.client,\n      ecosystem: this.ecosystem,\n    });\n  }\n\n  authenticateWithRedirect(\n    strategy: SocialAuthOption,\n    mode?: \"redirect\" | \"popup\" | \"window\",\n    redirectUrl?: string,\n  ): void {\n    loginWithOauthRedirect({\n      authOption: strategy,\n      client: this.client,\n      ecosystem: this.ecosystem,\n      redirectUrl,\n      mode,\n    });\n  }\n\n  async loginWithAuthToken(authResult: AuthStoredTokenWithCookieReturnType) {\n    return this.auth.loginWithAuthToken(authResult);\n  }\n\n  /**\n   * Authenticates the user and returns the auth token, but does not instantiate their wallet\n   */\n  async authenticate(\n    args: MultiStepAuthArgsType | SingleStepAuthArgsType,\n  ): Promise<AuthStoredTokenWithCookieReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"email\":\n        return verifyOtp({\n          ...args,\n          client: this.client,\n          ecosystem: this.ecosystem,\n        });\n      case \"phone\":\n        return verifyOtp({\n          ...args,\n          client: this.client,\n          ecosystem: this.ecosystem,\n        });\n      case \"jwt\":\n        return this.auth.authenticateWithCustomJwt({\n          jwt: args.jwt,\n          encryptionKey: args.encryptionKey,\n        });\n      case \"passkey\": {\n        return this.passkeyAuth(args);\n      }\n      case \"auth_endpoint\": {\n        return this.auth.authenticateWithCustomAuthEndpoint({\n          payload: args.payload,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"iframe_email_verification\": {\n        return this.auth.authenticateWithIframe({\n          email: args.email,\n        });\n      }\n      case \"iframe\": {\n        return this.auth.authenticateWithModal();\n      }\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"telegram\":\n      case \"twitch\":\n      case \"farcaster\":\n      case \"line\":\n      case \"x\":\n      case \"coinbase\":\n      case \"discord\": {\n        return loginWithOauth({\n          authOption: strategy,\n          client: this.client,\n          ecosystem: this.ecosystem,\n          closeOpenedWindow: args.closeOpenedWindow,\n          openedWindow: args.openedWindow,\n        });\n      }\n      case \"guest\": {\n        return guestAuthenticate({\n          client: this.client,\n          ecosystem: this.ecosystem,\n          storage: webLocalStorage,\n        });\n      }\n      case \"wallet\": {\n        return siweAuthenticate({\n          ecosystem: this.ecosystem,\n          client: this.client,\n          wallet: args.wallet,\n          chain: args.chain,\n        });\n      }\n    }\n  }\n\n  /**\n   * Authenticates the user then instantiates their wallet using the resulting auth token\n   */\n  async connect(\n    args: MultiStepAuthArgsType | SingleStepAuthArgsType,\n  ): Promise<AuthLoginReturnType> {\n    const strategy = args.strategy;\n    switch (strategy) {\n      case \"jwt\": {\n        return this.auth.loginWithCustomJwt({\n          jwt: args.jwt,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"auth_endpoint\": {\n        return this.auth.loginWithCustomAuthEndpoint({\n          payload: args.payload,\n          encryptionKey: args.encryptionKey,\n        });\n      }\n      case \"iframe_email_verification\": {\n        return this.auth.loginWithIframe({\n          email: args.email,\n        });\n      }\n      case \"iframe\": {\n        return this.auth.loginWithModal();\n      }\n      case \"passkey\": {\n        const authToken = await this.passkeyAuth(args);\n        return this.loginWithAuthToken(authToken);\n      }\n      case \"phone\":\n      case \"email\":\n      case \"wallet\":\n      case \"apple\":\n      case \"facebook\":\n      case \"google\":\n      case \"farcaster\":\n      case \"telegram\":\n      case \"line\":\n      case \"x\":\n      case \"guest\":\n      case \"coinbase\":\n      case \"twitch\":\n      case \"discord\": {\n        const authToken = await this.authenticate(args);\n        return await this.auth.loginWithAuthToken(authToken);\n      }\n\n      default:\n        assertUnreachable(strategy);\n    }\n  }\n\n  async logout(): Promise<LogoutReturnType> {\n    return await this.auth.logout();\n  }\n\n  private async passkeyAuth(\n    args: Extract<SingleStepAuthArgsType, { strategy: \"passkey\" }>,\n  ) {\n    const { PasskeyWebClient } = await import(\"./auth/passkeys.js\");\n    const { passkeyName, storeLastUsedPasskey = true } = args;\n    const passkeyClient = new PasskeyWebClient();\n    const storage = this.storage;\n    if (args.type === \"sign-up\") {\n      return registerPasskey({\n        client: this.client,\n        ecosystem: this.ecosystem,\n        username: passkeyName,\n        passkeyClient,\n        storage: storeLastUsedPasskey ? storage : undefined,\n        rp: {\n          id: this.passkeyDomain ?? window.location.hostname,\n          name: this.passkeyDomain ?? window.document.title,\n        },\n      });\n    }\n    return loginWithPasskey({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      passkeyClient,\n      storage: storeLastUsedPasskey ? storage : undefined,\n      rp: {\n        id: this.passkeyDomain ?? window.location.hostname,\n        name: this.passkeyDomain ?? window.document.title,\n      },\n    });\n  }\n\n  async linkProfile(args: AuthArgsType) {\n    const { storedToken } = await this.authenticate(args);\n    return await linkAccount({\n      client: args.client,\n      tokenToLink: storedToken.cookieString,\n      storage: this.storage,\n      ecosystem: args.ecosystem || this.ecosystem,\n    });\n  }\n\n  async getProfiles() {\n    return getLinkedProfilesInternal({\n      client: this.client,\n      ecosystem: this.ecosystem,\n      storage: this.storage,\n    });\n  }\n}\n\nfunction assertUnreachable(x: never, message?: string): never {\n  throw new Error(message ?? `Invalid param: ${x}`);\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport { randomBytesHex } from \"../../../../utils/random.js\";\nimport type { AsyncStorage } from \"../../../../utils/storage/AsyncStorage.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\nimport { ClientScopedStorage } from \"./client-scoped-storage.js\";\nimport { getLoginCallbackUrl } from \"./getLoginPath.js\";\nimport type { AuthStoredTokenWithCookieReturnType } from \"./types.js\";\n\n/**\n * Does no real authentication, just issues a temporary token for the user.\n * @internal\n */\nexport async function guestAuthenticate(args: {\n  client: ThirdwebClient;\n  storage: AsyncStorage;\n  ecosystem?: Ecosystem;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  const storage = new ClientScopedStorage({\n    storage: args.storage,\n    clientId: args.client.clientId,\n    ecosystem: args.ecosystem,\n  });\n\n  let sessionId = await storage.getGuestSessionId();\n  if (!sessionId) {\n    sessionId = randomBytesHex(32);\n    storage.saveGuestSessionId(sessionId);\n  }\n\n  const clientFetch = getClientFetch(args.client, args.ecosystem);\n  const authResult = await (async () => {\n    const path = getLoginCallbackUrl({\n      authOption: \"guest\",\n      client: args.client,\n      ecosystem: args.ecosystem,\n    });\n    const res = await clientFetch(`${path}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        sessionId,\n      }),\n    });\n\n    if (!res.ok) throw new Error(\"Failed to generate guest account\");\n\n    return (await res.json()) satisfies AuthStoredTokenWithCookieReturnType;\n  })();\n  return authResult;\n}\n","import { signLoginPayload } from \"../../../../auth/core/sign-login-payload.js\";\nimport type { LoginPayload } from \"../../../../auth/core/types.js\";\nimport type { Chain } from \"../../../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { Wallet } from \"../../../interfaces/wallet.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\nimport { getLoginCallbackUrl, getLoginUrl } from \"./getLoginPath.js\";\nimport type { AuthStoredTokenWithCookieReturnType } from \"./types.js\";\n\n/**\n * @internal\n */\nexport async function siweAuthenticate(args: {\n  wallet: Wallet;\n  chain: Chain;\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n}): Promise<AuthStoredTokenWithCookieReturnType> {\n  const { wallet, chain } = args;\n  const account = await wallet.connect({ client: args.client });\n  const clientFetch = getClientFetch(args.client, args.ecosystem);\n\n  const payload = await (async () => {\n    const path = getLoginUrl({\n      authOption: \"wallet\",\n      client: args.client,\n      ecosystem: args.ecosystem,\n    });\n    const res = await clientFetch(\n      `${path}&address=${account.address}&chainId=${chain.id}`,\n    );\n\n    if (!res.ok) throw new Error(\"Failed to generate SIWE login payload\");\n\n    return (await res.json()) satisfies LoginPayload;\n  })();\n  const { signature } = await signLoginPayload({ payload, account });\n\n  const authResult = await (async () => {\n    const path = getLoginCallbackUrl({\n      authOption: \"wallet\",\n      client: args.client,\n      ecosystem: args.ecosystem,\n    });\n    const res = await clientFetch(\n      `${path}&signature=${signature}&payload=${encodeURIComponent(payload)}`,\n      {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify({\n          signature,\n          payload,\n        }),\n      },\n    );\n\n    if (!res.ok) throw new Error(\"Failed to verify SIWE signature\");\n\n    return (await res.json()) satisfies AuthStoredTokenWithCookieReturnType;\n  })();\n  return authResult;\n}\n","import type { ThirdwebClient } from \"../../../../client/client.js\";\nimport { getThirdwebBaseUrl } from \"../../../../utils/domains.js\";\nimport { getClientFetch } from \"../../../../utils/fetch.js\";\nimport type { Ecosystem } from \"../wallet/types.js\";\nimport type { ClientScopedStorage } from \"./client-scoped-storage.js\";\nimport type { Profile } from \"./types.js\";\n\n/**\n * @description\n * Links a new account to the current one using an auth token.\n * For the public-facing API, use `wallet.linkProfile` instead.\n *\n * @internal\n */\nexport async function linkAccount({\n  client,\n  ecosystem,\n  tokenToLink,\n  storage,\n}: {\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n  tokenToLink: string;\n  storage: ClientScopedStorage;\n}): Promise<Profile[]> {\n  const clientFetch = getClientFetch(client, ecosystem);\n  const IN_APP_URL = getThirdwebBaseUrl(\"inAppWallet\");\n  const currentAccountToken = await storage.getAuthCookie();\n\n  if (!currentAccountToken) {\n    throw new Error(\"Failed to link account, no user logged in\");\n  }\n\n  const headers: Record<string, string> = {\n    Authorization: `Bearer iaw-auth-token:${currentAccountToken}`,\n    \"Content-Type\": \"application/json\",\n  };\n  const linkedDetailsResp = await clientFetch(\n    `${IN_APP_URL}/api/2024-05-05/account/connect`,\n    {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        accountAuthTokenToConnect: tokenToLink,\n      }),\n    },\n  );\n\n  if (!linkedDetailsResp.ok) {\n    const body = await linkedDetailsResp.json();\n    throw new Error(body.message || \"Failed to link account.\");\n  }\n\n  const { linkedAccounts } = await linkedDetailsResp.json();\n\n  return (linkedAccounts ?? []) satisfies Profile[];\n}\n\n/**\n * @description\n * Gets the linked accounts for the current user.\n * For the public-facing API, use `wallet.getProfiles` instead.\n *\n * @internal\n */\nexport async function getLinkedProfilesInternal({\n  client,\n  ecosystem,\n  storage,\n}: {\n  client: ThirdwebClient;\n  ecosystem?: Ecosystem;\n  storage: ClientScopedStorage;\n}): Promise<Profile[]> {\n  const clientFetch = getClientFetch(client, ecosystem);\n  const IN_APP_URL = getThirdwebBaseUrl(\"inAppWallet\");\n  const currentAccountToken = await storage.getAuthCookie();\n  if (!currentAccountToken) {\n    throw new Error(\"Failed to get linked accounts, no user logged in\");\n  }\n\n  const headers: Record<string, string> = {\n    Authorization: `Bearer iaw-auth-token:${currentAccountToken}`,\n    \"Content-Type\": \"application/json\",\n  };\n\n  const linkedAccountsResp = await clientFetch(\n    `${IN_APP_URL}/api/2024-05-05/accounts`,\n    {\n      method: \"GET\",\n      headers,\n    },\n  );\n\n  if (!linkedAccountsResp.ok) {\n    const body = await linkedAccountsResp.json();\n    throw new Error(body.message || \"Failed to get linked accounts.\");\n  }\n\n  const { linkedAccounts } = await linkedAccountsResp.json();\n\n  return (linkedAccounts ?? []) satisfies Profile[];\n}\n"],"names":["createLoginMessage","payload","prefix","domain","address","join","statement","suffixArray","uri","uriField","push","versionField","version","chain_id","chainField","nonceField","nonce","issuedAtField","issued_at","expiryField","expiration_time","invalid_before","invalidBeforeField","resources","map","x","async","signLoginPayload","options","account","signature","signMessage","message","eth_sendRawTransaction","request","signedTransaction","method","params","getUserStatus","_ref","authToken","client","ecosystem","clientFetch","getClientFetch","response","getThirdwebBaseUrl","headers","clientId","Authorization","ok","status","result","json","Error","error","randomBytesHex","length","arguments","undefined","uint8ArrayToHex","globalThis","crypto","getRandomValues","Uint8Array","randomBytesBuffer","getVerificationPath","getChallengePath","type","username","registerPasskey","passkeyClient","isAvailable","fetchWithId","generatedName","id","Date","toISOString","res","challengeData","challenge","registration","register","name","rp","customHeaders","partnerId","verifRes","body","JSON","stringify","authenticatorData","credentialId","serverVerificationId","clientData","credential","publicKey","algorithm","origin","rpId","verifData","storedToken","storage","savePasskeyCredentialId","EnclaveWallet","constructor","Object","defineProperty","this","localStorage","postWalletSetUp","authResult","saveAuthCookie","cookieString","getUserWalletStatus","token","getAuthCookie","userStatus","wallet","wallets","authDetails","email","linkedAccounts","find","details","phoneNumber","phone","userWalletId","recoveryShareManagement","walletAddress","getAccount","_signTransaction","rpcRequest","getRpcClient","chain","getCachedChain","tx","chainId","transaction","to","data","toHex","value","gas","BigInt","then","_ref2","eth_getTransactionCount","blockTag","maxFeePerGas","maxPriorityFeePerGas","gasPrice","transactionPayload","signEnclaveTransaction","getAddress","signTransaction","sendTransaction","signedTx","transactionHash","_ref3","messagePayload","isRaw","raw","bytesToHex","signEnclaveMessage","signTypedData","_typedData","parsedTypedData","parseTypedData","signEnclaveTypedData","iframeBaseStyle","height","width","border","backgroundColor","colorScheme","position","top","right","zIndex","display","pointerEvents","isIframeLoaded","Map","IframeCommunicator","link","baseUrl","iframeId","container","document","onIframeInitialize","iframeBaseUrl","iframe","getElementById","hrefLink","URL","src","href","createElement","mergedIframeStyles","assign","style","setAttribute","appendChild","onIframeLoaded","event","eventType","window","removeEventListener","console","warn","onIframeLoadHandler","addEventListener","onIframeLoadedInitVariables","authCookie","deviceShareStored","getDeviceShare","walletUserId","getWalletUserId","ecosystemId","channel","MessageChannel","promise","Promise","rej","port1","onmessage","close","success","set","contentWindow","postMessage","port2","call","procedureName","showIframe","get","sleep","POLLING_INTERVAL_SECONDS","destroy","delete","InAppWalletIframeCommunicator","super","IN_APP_WALLET_IFRAME_ID","createInAppWalletIframeLink","path","IN_APP_WALLET_PATH","ClientScopedStorage","webLocalStorage","queryParams","inAppWalletUrl","queryKey","keys","searchParams","toString","AbstractLogin","querier","preLogin","postLogin","LoginQuerier","sendEmailLoginOtp","sendSmsLoginOtp","BaseLogin","authenticateWithModal","loginWithModal","authenticateWithIframe","loginWithIframe","authenticateWithCustomJwt","encryptionKey","jwt","loginWithCustomJwt","_ref4","authenticateWithCustomAuthEndpoint","_ref5","loginWithCustomAuthEndpoint","_ref6","authenticateWithEmailOtp","_ref7","otp","recoveryCode","loginWithEmailOtp","_ref8","authenticateWithSmsOtp","_ref9","loginWithSmsOtp","_ref10","Auth","onAuthSuccess","AuthQuerier","logout","walletDetails","shouldStoreCookieString","loginWithAuthToken","user","generateWallet","args","isRemoveAuthCookie","removeAuthCookie","isRemoveUserId","removeWalletUserId","verifyOtp","url","getLoginCallbackUrl","authOption","strategy","code","verificationCode","fetch","IFrameWallet","walletManagerQuerier","saveDeviceShare","gasLimit","accessList","RPC_URL","getThirdwebDomains","rpc","rpcEndpoint","messageDecoded","hexToString","signedMessage","types","EIP712Domain","domainData","verifyingContract","signedTypedData","InAppWebConnector","isClientIdLegacyPaper","indexOf","passkeyDomain","auth","walletType","initializeWallet","storedAuthToken","getUser","localAuthToken","preAuthenticate","getLoginUrl","sendOtp","authenticateWithRedirect","mode","redirectUrl","loginWithOauthRedirect","authenticate","passkeyAuth","loginWithOauth","closeOpenedWindow","openedWindow","sessionId","getGuestSessionId","saveGuestSessionId","guestAuthenticate","connect","encodeURIComponent","siweAuthenticate","assertUnreachable","PasskeyWebClient","passkeyName","storeLastUsedPasskey","location","hostname","title","getPasskeyCredentialId","authentication","loginWithPasskey","linkProfile","tokenToLink","IN_APP_URL","currentAccountToken","linkedDetailsResp","accountAuthTokenToConnect","linkAccount","getProfiles","linkedAccountsResp","getLinkedProfilesInternal"],"sourceRoot":""}