{"version":3,"file":"static/js/86394.85b4b49c.chunk.js","mappings":"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","sources":["../node_modules/viem/errors/request.ts","../node_modules/viem/errors/rpc.ts","../node_modules/thirdweb/src/wallets/wallet-connect/controller.ts"],"sourcesContent":["import { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type HttpRequestErrorType = HttpRequestError & {\n  name: 'HttpRequestError'\n}\nexport class HttpRequestError extends BaseError {\n  body?: { [x: string]: unknown } | { [y: string]: unknown }[] | undefined\n  headers?: Headers | undefined\n  status?: number | undefined\n  url: string\n\n  constructor({\n    body,\n    cause,\n    details,\n    headers,\n    status,\n    url,\n  }: {\n    body?: { [x: string]: unknown } | { [y: string]: unknown }[] | undefined\n    cause?: Error | undefined\n    details?: string | undefined\n    headers?: Headers | undefined\n    status?: number | undefined\n    url: string\n  }) {\n    super('HTTP request failed.', {\n      cause,\n      details,\n      metaMessages: [\n        status && `Status: ${status}`,\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n      name: 'HttpRequestError',\n    })\n    this.body = body\n    this.headers = headers\n    this.status = status\n    this.url = url\n  }\n}\n\nexport type WebSocketRequestErrorType = WebSocketRequestError & {\n  name: 'WebSocketRequestError'\n}\nexport class WebSocketRequestError extends BaseError {\n  constructor({\n    body,\n    cause,\n    details,\n    url,\n  }: {\n    body?: { [key: string]: unknown } | undefined\n    cause?: Error | undefined\n    details?: string | undefined\n    url: string\n  }) {\n    super('WebSocket request failed.', {\n      cause,\n      details,\n      metaMessages: [\n        `URL: ${getUrl(url)}`,\n        body && `Request body: ${stringify(body)}`,\n      ].filter(Boolean) as string[],\n      name: 'WebSocketRequestError',\n    })\n  }\n}\n\nexport type RpcRequestErrorType = RpcRequestError & {\n  name: 'RpcRequestError'\n}\nexport class RpcRequestError extends BaseError {\n  code: number\n\n  constructor({\n    body,\n    error,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    error: { code: number; message: string }\n    url: string\n  }) {\n    super('RPC Request failed.', {\n      cause: error as any,\n      details: error.message,\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n      name: 'RpcRequestError',\n    })\n    this.code = error.code\n  }\n}\n\nexport type SocketClosedErrorType = SocketClosedError & {\n  name: 'SocketClosedError'\n}\nexport class SocketClosedError extends BaseError {\n  constructor({\n    url,\n  }: {\n    url?: string | undefined\n  } = {}) {\n    super('The socket has been closed.', {\n      metaMessages: [url && `URL: ${getUrl(url)}`].filter(Boolean) as string[],\n      name: 'SocketClosedError',\n    })\n  }\n}\n\nexport type TimeoutErrorType = TimeoutError & {\n  name: 'TimeoutError'\n}\nexport class TimeoutError extends BaseError {\n  constructor({\n    body,\n    url,\n  }: {\n    body: { [x: string]: unknown } | { [y: string]: unknown }[]\n    url: string\n  }) {\n    super('The request took too long to respond.', {\n      details: 'The request timed out.',\n      metaMessages: [`URL: ${getUrl(url)}`, `Request body: ${stringify(body)}`],\n      name: 'TimeoutError',\n    })\n  }\n}\n","import type { Prettify } from '../types/utils.js'\nimport { BaseError } from './base.js'\nimport { RpcRequestError } from './request.js'\n\nconst unknownErrorCode = -1\n\nexport type RpcErrorCode =\n  | -1\n  | -32700 // Parse error\n  | -32600 // Invalid request\n  | -32601 // Method not found\n  | -32602 // Invalid params\n  | -32603 // Internal error\n  | -32000 // Invalid input\n  | -32001 // Resource not found\n  | -32002 // Resource unavailable\n  | -32003 // Transaction rejected\n  | -32004 // Method not supported\n  | -32005 // Limit exceeded\n  | -32006 // JSON-RPC version not supported\n  | -32042 // Method not found\n\ntype RpcErrorOptions<code extends number = RpcErrorCode> = {\n  code?: code | (number & {}) | undefined\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  name?: string | undefined\n  shortMessage: string\n}\n\n/**\n * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1474\n */\nexport type RpcErrorType = RpcError & { name: 'RpcError' }\nexport class RpcError<code_ extends number = RpcErrorCode> extends BaseError {\n  code: code_ | (number & {})\n\n  constructor(\n    cause: Error,\n    {\n      code,\n      docsPath,\n      metaMessages,\n      name,\n      shortMessage,\n    }: RpcErrorOptions<code_>,\n  ) {\n    super(shortMessage, {\n      cause,\n      docsPath,\n      metaMessages:\n        metaMessages || (cause as { metaMessages?: string[] })?.metaMessages,\n      name: name || 'RpcError',\n    })\n    this.name = name || cause.name\n    this.code = (\n      cause instanceof RpcRequestError ? cause.code : code ?? unknownErrorCode\n    ) as code_\n  }\n}\n\nexport type ProviderRpcErrorCode =\n  | 4001 // User Rejected Request\n  | 4100 // Unauthorized\n  | 4200 // Unsupported Method\n  | 4900 // Disconnected\n  | 4901 // Chain Disconnected\n  | 4902 // Chain Not Recognized\n\n/**\n * Error subclass implementing Ethereum Provider errors per EIP-1193.\n *\n * - EIP https://eips.ethereum.org/EIPS/eip-1193\n */\nexport type ProviderRpcErrorType = ProviderRpcError & {\n  name: 'ProviderRpcError'\n}\nexport class ProviderRpcError<\n  T = undefined,\n> extends RpcError<ProviderRpcErrorCode> {\n  data?: T | undefined\n\n  constructor(\n    cause: Error,\n    options: Prettify<\n      RpcErrorOptions<ProviderRpcErrorCode> & {\n        data?: T | undefined\n      }\n    >,\n  ) {\n    super(cause, options)\n\n    this.data = options.data\n  }\n}\n\n/**\n * Subclass for a \"Parse error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ParseRpcErrorType = ParseRpcError & {\n  code: -32700\n  name: 'ParseRpcError'\n}\nexport class ParseRpcError extends RpcError {\n  static code = -32700 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ParseRpcError.code,\n      name: 'ParseRpcError',\n      shortMessage:\n        'Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Invalid request\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidRequestRpcErrorType = InvalidRequestRpcError & {\n  code: -32600\n  name: 'InvalidRequestRpcError'\n}\nexport class InvalidRequestRpcError extends RpcError {\n  static code = -32600 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidRequestRpcError.code,\n      name: 'InvalidRequestRpcError',\n      shortMessage: 'JSON is not a valid request object.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type MethodNotFoundRpcErrorType = MethodNotFoundRpcError & {\n  code: -32601\n  name: 'MethodNotFoundRpcError'\n}\nexport class MethodNotFoundRpcError extends RpcError {\n  static code = -32601 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: MethodNotFoundRpcError.code,\n      name: 'MethodNotFoundRpcError',\n      shortMessage: `The method${method ? ` \"${method}\"` : ''} does not exist / is not available.`,\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid params\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidParamsRpcErrorType = InvalidParamsRpcError & {\n  code: -32602\n  name: 'InvalidParamsRpcError'\n}\nexport class InvalidParamsRpcError extends RpcError {\n  static code = -32602 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidParamsRpcError.code,\n      name: 'InvalidParamsRpcError',\n      shortMessage: [\n        'Invalid parameters were provided to the RPC method.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for an \"Internal error\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InternalRpcErrorType = InternalRpcError & {\n  code: -32603\n  name: 'InternalRpcError'\n}\nexport class InternalRpcError extends RpcError {\n  static code = -32603 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InternalRpcError.code,\n      name: 'InternalRpcError',\n      shortMessage: 'An internal error was received.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Invalid input\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type InvalidInputRpcErrorType = InvalidInputRpcError & {\n  code: -32000\n  name: 'InvalidInputRpcError'\n}\nexport class InvalidInputRpcError extends RpcError {\n  static code = -32000 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: InvalidInputRpcError.code,\n      name: 'InvalidInputRpcError',\n      shortMessage: [\n        'Missing or invalid parameters.',\n        'Double check you have provided the correct parameters.',\n      ].join('\\n'),\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource not found\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ResourceNotFoundRpcErrorType = ResourceNotFoundRpcError & {\n  code: -32001\n  name: 'ResourceNotFoundRpcError'\n}\nexport class ResourceNotFoundRpcError extends RpcError {\n  override name = 'ResourceNotFoundRpcError'\n  static code = -32001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceNotFoundRpcError.code,\n      name: 'ResourceNotFoundRpcError',\n      shortMessage: 'Requested resource not found.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Resource unavailable\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type ResourceUnavailableRpcErrorType = ResourceUnavailableRpcError & {\n  code: -32002\n  name: 'ResourceUnavailableRpcError'\n}\nexport class ResourceUnavailableRpcError extends RpcError {\n  static code = -32002 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ResourceUnavailableRpcError.code,\n      name: 'ResourceUnavailableRpcError',\n      shortMessage: 'Requested resource not available.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Transaction rejected\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type TransactionRejectedRpcErrorType = TransactionRejectedRpcError & {\n  code: -32003\n  name: 'TransactionRejectedRpcError'\n}\nexport class TransactionRejectedRpcError extends RpcError {\n  static code = -32003 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: TransactionRejectedRpcError.code,\n      name: 'TransactionRejectedRpcError',\n      shortMessage: 'Transaction creation failed.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"Method not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type MethodNotSupportedRpcErrorType = MethodNotSupportedRpcError & {\n  code: -32004\n  name: 'MethodNotSupportedRpcError'\n}\nexport class MethodNotSupportedRpcError extends RpcError {\n  static code = -32004 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: MethodNotSupportedRpcError.code,\n      name: 'MethodNotSupportedRpcError',\n      shortMessage: `Method${method ? ` \"${method}\"` : ''} is not implemented.`,\n    })\n  }\n}\n\n/**\n * Subclass for a \"Limit exceeded\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type LimitExceededRpcErrorType = LimitExceededRpcError & {\n  code: -32005\n  name: 'LimitExceededRpcError'\n}\nexport class LimitExceededRpcError extends RpcError {\n  static code = -32005 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: LimitExceededRpcError.code,\n      name: 'LimitExceededRpcError',\n      shortMessage: 'Request exceeds defined limit.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"JSON-RPC version not supported\" EIP-1474 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1474#error-codes\n */\nexport type JsonRpcVersionUnsupportedErrorType =\n  JsonRpcVersionUnsupportedError & {\n    code: -32006\n    name: 'JsonRpcVersionUnsupportedError'\n  }\nexport class JsonRpcVersionUnsupportedError extends RpcError {\n  static code = -32006 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: JsonRpcVersionUnsupportedError.code,\n      name: 'JsonRpcVersionUnsupportedError',\n      shortMessage: 'Version of JSON-RPC protocol is not supported.',\n    })\n  }\n}\n\n/**\n * Subclass for a \"User Rejected Request\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UserRejectedRequestErrorType = UserRejectedRequestError & {\n  code: 4001\n  name: 'UserRejectedRequestError'\n}\nexport class UserRejectedRequestError extends ProviderRpcError {\n  static code = 4001 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UserRejectedRequestError.code,\n      name: 'UserRejectedRequestError',\n      shortMessage: 'User rejected the request.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unauthorized\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UnauthorizedProviderErrorType = UnauthorizedProviderError & {\n  code: 4100\n  name: 'UnauthorizedProviderError'\n}\nexport class UnauthorizedProviderError extends ProviderRpcError {\n  static code = 4100 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: UnauthorizedProviderError.code,\n      name: 'UnauthorizedProviderError',\n      shortMessage:\n        'The requested method and/or account has not been authorized by the user.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Unsupported Method\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type UnsupportedProviderMethodErrorType =\n  UnsupportedProviderMethodError & {\n    code: 4200\n    name: 'UnsupportedProviderMethodError'\n  }\nexport class UnsupportedProviderMethodError extends ProviderRpcError {\n  static code = 4200 as const\n\n  constructor(cause: Error, { method }: { method?: string } = {}) {\n    super(cause, {\n      code: UnsupportedProviderMethodError.code,\n      name: 'UnsupportedProviderMethodError',\n      shortMessage: `The Provider does not support the requested method${method ? ` \" ${method}\"` : ''}.`,\n    })\n  }\n}\n\n/**\n * Subclass for an \"Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type ProviderDisconnectedErrorType = ProviderDisconnectedError & {\n  code: 4900\n  name: 'ProviderDisconnectedError'\n}\nexport class ProviderDisconnectedError extends ProviderRpcError {\n  static code = 4900 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ProviderDisconnectedError.code,\n      name: 'ProviderDisconnectedError',\n      shortMessage: 'The Provider is disconnected from all chains.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Chain Disconnected\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type ChainDisconnectedErrorType = ChainDisconnectedError & {\n  code: 4901\n  name: 'ChainDisconnectedError'\n}\nexport class ChainDisconnectedError extends ProviderRpcError {\n  static code = 4901 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: ChainDisconnectedError.code,\n      name: 'ChainDisconnectedError',\n      shortMessage: 'The Provider is not connected to the requested chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an \"Switch Chain\" EIP-1193 error.\n *\n * EIP https://eips.ethereum.org/EIPS/eip-1193#provider-errors\n */\nexport type SwitchChainErrorType = SwitchChainError & {\n  code: 4902\n  name: 'SwitchChainError'\n}\nexport class SwitchChainError extends ProviderRpcError {\n  static code = 4902 as const\n\n  constructor(cause: Error) {\n    super(cause, {\n      code: SwitchChainError.code,\n      name: 'SwitchChainError',\n      shortMessage: 'An error occurred when attempting to switch chain.',\n    })\n  }\n}\n\n/**\n * Subclass for an unknown RPC error.\n */\nexport type UnknownRpcErrorType = UnknownRpcError & {\n  name: 'UnknownRpcError'\n}\nexport class UnknownRpcError extends RpcError {\n  constructor(cause: Error) {\n    super(cause, {\n      name: 'UnknownRpcError',\n      shortMessage: 'An unknown RPC error occurred.',\n    })\n  }\n}\n","import type { EthereumProvider } from \"@walletconnect/ethereum-provider\";\nimport type { Address } from \"abitype\";\nimport {\n  type ProviderRpcError,\n  type SignTypedDataParameters,\n  SwitchChainError,\n  UserRejectedRequestError,\n  getTypesForEIP712Domain,\n  serializeTypedData,\n  validateTypedData,\n} from \"viem\";\nimport type { Chain } from \"../../chains/types.js\";\nimport {\n  getCachedChain,\n  getChainMetadata,\n  getRpcUrlForChain,\n} from \"../../chains/utils.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport {\n  type Hex,\n  numberToHex,\n  stringToHex,\n  uint8ArrayToHex,\n} from \"../../utils/encoding/hex.js\";\nimport { parseTypedData } from \"../../utils/signatures/helpers/parseTypedData.js\";\nimport type { AsyncStorage } from \"../../utils/storage/AsyncStorage.js\";\nimport {\n  getSavedConnectParamsFromStorage,\n  saveConnectParamsToStorage,\n} from \"../../utils/storage/walletStorage.js\";\nimport { formatWalletConnectUrl } from \"../../utils/url.js\";\nimport { getWalletInfo } from \"../__generated__/getWalletInfo.js\";\nimport type { WCSupportedWalletIds } from \"../__generated__/wallet-ids.js\";\nimport type {\n  Account,\n  SendTransactionOption,\n  Wallet,\n} from \"../interfaces/wallet.js\";\nimport type { DisconnectFn, SwitchChainFn } from \"../types.js\";\nimport { getValidPublicRPCUrl } from \"../utils/chains.js\";\nimport { getDefaultAppMetadata } from \"../utils/defaultDappMetadata.js\";\nimport { normalizeChainId } from \"../utils/normalizeChainId.js\";\nimport type { WalletEmitter } from \"../wallet-emitter.js\";\nimport type { WalletId } from \"../wallet-types.js\";\nimport { DEFAULT_PROJECT_ID, NAMESPACE } from \"./constants.js\";\nimport type { WCAutoConnectOptions, WCConnectOptions } from \"./types.js\";\n\ntype WCProvider = InstanceType<typeof EthereumProvider>;\n\ntype SavedConnectParams = {\n  optionalChains?: Chain[];\n  chain?: Chain;\n  pairingTopic?: string;\n};\n\nconst ADD_ETH_CHAIN_METHOD = \"wallet_addEthereumChain\";\n\nconst defaultShowQrModal = true;\n\nconst storageKeys = {\n  requestedChains: \"tw.wc.requestedChains\",\n  lastUsedChainId: \"tw.wc.lastUsedChainId\",\n};\n\n/**\n * Checks if the provided wallet is a Wallet Connect wallet.\n *\n * @param wallet - The wallet to check.\n * @returns True if the wallet is a Wallet Connect wallet, false otherwise.\n */\nexport function isWalletConnect(\n  wallet: Wallet<WalletId>,\n): wallet is Wallet<\"walletConnect\"> {\n  return wallet.id === \"walletConnect\";\n}\n\n/**\n * @internal\n */\nexport async function connectWC(\n  options: WCConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const provider = await initProvider(options, walletId, sessionHandler);\n  const wcOptions = options.walletConnect;\n\n  let { onDisplayUri } = wcOptions || {};\n\n  // use default sessionHandler unless onDisplayUri is explicitly provided\n  if (!onDisplayUri && sessionHandler && walletId !== \"walletConnect\") {\n    const walletInfo = await getWalletInfo(walletId);\n    const deeplinkHandler = (uri: string) => {\n      const appUrl = walletInfo.mobile.native || walletInfo.mobile.universal;\n      if (!appUrl) {\n        throw new Error(\"No app url found for wallet connect to redirect to.\");\n      }\n      const fullUrl = formatWalletConnectUrl(appUrl, uri).redirect;\n      sessionHandler(fullUrl);\n    };\n    onDisplayUri = deeplinkHandler;\n  }\n\n  if (onDisplayUri) {\n    provider.events.addListener(\"display_uri\", onDisplayUri);\n  }\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const {\n    rpcMap,\n    requiredChain,\n    optionalChains: chainsToRequest,\n  } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains,\n  });\n\n  if (provider.session) {\n    await provider.connect({\n      ...(wcOptions?.pairingTopic\n        ? { pairingTopic: wcOptions?.pairingTopic }\n        : {}),\n      optionalChains: chainsToRequest,\n      chains: requiredChain ? [requiredChain.id] : undefined,\n      rpcMap: rpcMap,\n    });\n  }\n\n  setRequestedChainsIds(chainsToRequest, storage);\n  // If session exists and chains are authorized, enable provider for required chain\n  const addresses = await provider.enable();\n  const address = addresses[0];\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  if (options) {\n    const savedParams: SavedConnectParams = {\n      optionalChains: options.walletConnect?.optionalChains,\n      chain: options.chain,\n      pairingTopic: options.walletConnect?.pairingTopic,\n    };\n\n    if (storage) {\n      saveConnectParamsToStorage(storage, walletId, savedParams);\n    }\n  }\n\n  if (wcOptions?.onDisplayUri) {\n    provider.events.removeListener(\"display_uri\", wcOptions.onDisplayUri);\n  }\n\n  return onConnect(address, chain, provider, emitter, storage);\n}\n\n/**\n * Auto connect to already connected wallet connect session.\n * @internal\n */\nexport async function autoConnectWC(\n  options: WCAutoConnectOptions,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  storage: AsyncStorage,\n  sessionHandler?: (uri: string) => void,\n): Promise<ReturnType<typeof onConnect>> {\n  const savedConnectParams: SavedConnectParams | null = storage\n    ? await getSavedConnectParamsFromStorage(storage, walletId)\n    : null;\n\n  const provider = await initProvider(\n    savedConnectParams\n      ? {\n          chain: savedConnectParams.chain,\n          client: options.client,\n          walletConnect: {\n            pairingTopic: savedConnectParams.pairingTopic,\n            optionalChains: savedConnectParams.optionalChains,\n          },\n        }\n      : {\n          client: options.client,\n          walletConnect: {},\n        },\n    walletId,\n    sessionHandler,\n    true, // is auto connect\n  );\n\n  const address = provider.accounts[0];\n\n  if (!address) {\n    throw new Error(\"No accounts found on provider.\");\n  }\n\n  const providerChainId = normalizeChainId(provider.chainId);\n\n  const chain =\n    options.chain && options.chain.id === providerChainId\n      ? options.chain\n      : getCachedChain(providerChainId);\n\n  return onConnect(address, chain, provider, emitter, storage);\n}\n\n// Connection utils -----------------------------------------------------------------------------------------------\n\nasync function initProvider(\n  options: WCConnectOptions,\n  walletId: WCSupportedWalletIds | \"walletConnect\",\n  sessionRequestHandler?: (uri: string) => void | Promise<void>,\n  isAutoConnect = false,\n) {\n  const walletInfo = await getWalletInfo(walletId);\n  const wcOptions = options.walletConnect;\n  const { EthereumProvider, OPTIONAL_EVENTS, OPTIONAL_METHODS } = await import(\n    \"@walletconnect/ethereum-provider\"\n  );\n\n  let optionalChains: Chain[] | undefined = wcOptions?.optionalChains;\n  let chainToRequest = options.chain;\n\n  // ignore the given options chains - and set the safe supported chains\n  if (walletId === \"global.safe\") {\n    optionalChains = chainsToRequestForSafe.map(getCachedChain);\n    if (chainToRequest && !optionalChains.includes(chainToRequest)) {\n      chainToRequest = undefined;\n    }\n  }\n\n  const {\n    rpcMap,\n    requiredChain,\n    optionalChains: chainsToRequest,\n  } = getChainsToRequest({\n    client: options.client,\n    chain: chainToRequest,\n    optionalChains: optionalChains,\n  });\n\n  const provider = await EthereumProvider.init({\n    showQrModal:\n      wcOptions?.showQrModal === undefined\n        ? sessionRequestHandler\n          ? false\n          : defaultShowQrModal\n        : wcOptions.showQrModal,\n    projectId: wcOptions?.projectId || DEFAULT_PROJECT_ID,\n    optionalMethods: OPTIONAL_METHODS,\n    optionalEvents: OPTIONAL_EVENTS,\n    optionalChains: chainsToRequest,\n    chains: requiredChain ? [requiredChain.id] : undefined,\n    metadata: {\n      name: wcOptions?.appMetadata?.name || getDefaultAppMetadata().name,\n      description:\n        wcOptions?.appMetadata?.description ||\n        getDefaultAppMetadata().description,\n      url: wcOptions?.appMetadata?.url || getDefaultAppMetadata().url,\n      icons: [\n        wcOptions?.appMetadata?.logoUrl || getDefaultAppMetadata().logoUrl,\n      ],\n    },\n    rpcMap: rpcMap,\n    qrModalOptions: wcOptions?.qrModalOptions,\n    disableProviderPing: true,\n  });\n\n  provider.events.setMaxListeners(Number.POSITIVE_INFINITY);\n\n  // disconnect the provider if chains are stale when (if not auto connecting)\n  if (!isAutoConnect) {\n    // const isStale = await isChainsStale(provider, chainsToRequest);\n\n    if (provider.session) {\n      await provider.disconnect();\n    }\n  }\n\n  if (walletId !== \"walletConnect\") {\n    async function handleSessionRequest() {\n      const walletLinkToOpen =\n        provider.session?.peer?.metadata?.redirect?.native ||\n        walletInfo.mobile.native ||\n        walletInfo.mobile.universal;\n\n      if (sessionRequestHandler && walletLinkToOpen) {\n        // TODO: propagate error when this fails\n        await sessionRequestHandler(walletLinkToOpen);\n      }\n    }\n\n    provider.signer.client.on(\"session_request_sent\", handleSessionRequest);\n    provider.events.addListener(\"disconnect\", () => {\n      provider.signer.client.off(\"session_request_sent\", handleSessionRequest);\n    });\n  }\n\n  return provider;\n}\n\nfunction createAccount(provider: WCProvider, _address: string) {\n  const address = getAddress(_address);\n  const account: Account = {\n    address: address,\n    async sendTransaction(tx: SendTransactionOption) {\n      const transactionHash = (await provider.request({\n        method: \"eth_sendTransaction\",\n        params: [\n          {\n            gas: tx.gas ? numberToHex(tx.gas) : undefined,\n            value: tx.value ? numberToHex(tx.value) : undefined,\n            from: this.address,\n            to: tx.to as Address,\n            data: tx.data,\n          },\n        ],\n      })) as Hex;\n\n      return {\n        transactionHash,\n      };\n    },\n    async signMessage({ message }) {\n      const messageToSign = (() => {\n        if (typeof message === \"string\") {\n          return stringToHex(message);\n        }\n        if (message.raw instanceof Uint8Array) {\n          return uint8ArrayToHex(message.raw);\n        }\n        return message.raw;\n      })();\n      return provider.request({\n        method: \"personal_sign\",\n        params: [messageToSign, this.address],\n      });\n    },\n    async signTypedData(_data) {\n      const data = parseTypedData(_data);\n      const { domain, message, primaryType } =\n        data as unknown as SignTypedDataParameters;\n\n      const types = {\n        EIP712Domain: getTypesForEIP712Domain({ domain }),\n        ...data.types,\n      };\n\n      // Need to do a runtime validation check on addresses, byte ranges, integer ranges, etc\n      // as we can't statically check this with TypeScript.\n      validateTypedData({ domain, message, primaryType, types });\n\n      const typedData = serializeTypedData({\n        domain: domain ?? {},\n        message,\n        primaryType,\n        types,\n      });\n\n      return await provider.request({\n        method: \"eth_signTypedData_v4\",\n        params: [this.address, typedData],\n      });\n    },\n  };\n\n  return account;\n}\n\nfunction onConnect(\n  address: string,\n  chain: Chain,\n  provider: WCProvider,\n  emitter: WalletEmitter<WCSupportedWalletIds>,\n  storage: AsyncStorage,\n): [Account, Chain, DisconnectFn, SwitchChainFn] {\n  const account = createAccount(provider, address);\n\n  async function disconnect() {\n    provider.removeListener(\"accountsChanged\", onAccountsChanged);\n    provider.removeListener(\"chainChanged\", onChainChanged);\n    provider.removeListener(\"disconnect\", onDisconnect);\n    await provider.disconnect();\n  }\n\n  function onDisconnect() {\n    setRequestedChainsIds([], storage);\n    storage?.removeItem(storageKeys.lastUsedChainId);\n    disconnect();\n    emitter.emit(\"disconnect\", undefined);\n  }\n\n  function onAccountsChanged(accounts: string[]) {\n    if (accounts[0]) {\n      const newAccount = createAccount(provider, getAddress(accounts[0]));\n      emitter.emit(\"accountChanged\", newAccount);\n      emitter.emit(\"accountsChanged\", accounts);\n    } else {\n      onDisconnect();\n    }\n  }\n\n  function onChainChanged(newChainId: string) {\n    const newChain = getCachedChain(normalizeChainId(newChainId));\n    emitter.emit(\"chainChanged\", newChain);\n    storage?.setItem(storageKeys.lastUsedChainId, String(newChainId));\n  }\n\n  provider.on(\"accountsChanged\", onAccountsChanged);\n  provider.on(\"chainChanged\", onChainChanged);\n  provider.on(\"disconnect\", onDisconnect);\n  provider.on(\"session_delete\", onDisconnect);\n\n  return [\n    account,\n    chain,\n    disconnect,\n    (newChain) => switchChainWC(provider, newChain, storage),\n  ];\n}\n\n// Storage utils  -----------------------------------------------------------------------------------------------\n\nfunction getNamespaceMethods(provider: WCProvider) {\n  return provider.session?.namespaces[NAMESPACE]?.methods || [];\n}\n\nfunction getNamespaceChainsIds(provider: WCProvider): number[] {\n  const chainIds = provider.session?.namespaces[NAMESPACE]?.chains?.map(\n    (chain) => Number.parseInt(chain.split(\":\")[1] || \"\"),\n  );\n\n  return chainIds ?? [];\n}\n\nasync function switchChainWC(\n  provider: WCProvider,\n  chain: Chain,\n  storage: AsyncStorage,\n) {\n  const chainId = chain.id;\n  try {\n    const namespaceChains = getNamespaceChainsIds(provider);\n    const namespaceMethods = getNamespaceMethods(provider);\n    const isChainApproved = namespaceChains.includes(chainId);\n\n    if (!isChainApproved && namespaceMethods.includes(ADD_ETH_CHAIN_METHOD)) {\n      const apiChain = await getChainMetadata(chain);\n\n      const blockExplorerUrls = [\n        ...new Set([\n          ...(chain.blockExplorers?.map((x) => x.url) || []),\n          ...(apiChain.explorers?.map((x) => x.url) || []),\n        ]),\n      ];\n\n      await provider.request({\n        method: ADD_ETH_CHAIN_METHOD,\n        params: [\n          {\n            chainId: numberToHex(apiChain.chainId),\n            chainName: apiChain.name,\n            nativeCurrency: apiChain.nativeCurrency,\n            rpcUrls: getValidPublicRPCUrl(apiChain), // no clientId on purpose\n            blockExplorerUrls:\n              blockExplorerUrls.length > 0 ? blockExplorerUrls : undefined,\n          },\n        ],\n      });\n      const requestedChains = await getRequestedChainsIds(storage);\n      requestedChains.push(chainId);\n      setRequestedChainsIds(requestedChains, storage);\n    }\n    await provider.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: numberToHex(chainId) }],\n    });\n  } catch (error) {\n    const message =\n      typeof error === \"string\" ? error : (error as ProviderRpcError)?.message;\n    if (/user rejected request/i.test(message)) {\n      throw new UserRejectedRequestError(error as Error);\n    }\n\n    throw new SwitchChainError(error as Error);\n  }\n}\n\n/**\n * Set the requested chains to the storage.\n * @internal\n */\nfunction setRequestedChainsIds(\n  chains: number[] | undefined,\n  storage: AsyncStorage,\n) {\n  storage?.setItem(storageKeys.requestedChains, JSON.stringify(chains));\n}\n\n/**\n * Get the last requested chains from the storage.\n * @internal\n */\nasync function getRequestedChainsIds(storage: AsyncStorage): Promise<number[]> {\n  const data = await storage.getItem(storageKeys.requestedChains);\n  return data ? JSON.parse(data) : [];\n}\n\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\nfunction getChainsToRequest(options: {\n  chain?: Chain;\n  optionalChains?: Chain[];\n  client: ThirdwebClient;\n}): {\n  rpcMap: Record<number, string>;\n  requiredChain: Chain | undefined;\n  optionalChains: ArrayOneOrMore<number>;\n} {\n  const rpcMap: Record<number, string> = {};\n\n  if (options.chain) {\n    rpcMap[options.chain.id] = getRpcUrlForChain({\n      chain: options.chain,\n      client: options.client,\n    });\n  }\n\n  // limit optional chains to 10\n  const optionalChains = (options?.optionalChains || []).slice(0, 10);\n\n  for (const chain of optionalChains) {\n    rpcMap[chain.id] = getRpcUrlForChain({\n      chain: chain,\n      client: options.client,\n    });\n  }\n\n  if (!options.chain && optionalChains.length === 0) {\n    rpcMap[1] = getCachedChain(1).rpc;\n  }\n\n  return {\n    rpcMap,\n    requiredChain: options.chain ? options.chain : undefined,\n    optionalChains:\n      optionalChains.length > 0\n        ? (optionalChains.map((x) => x.id) as ArrayOneOrMore<number>)\n        : [1],\n  };\n}\n\nconst chainsToRequestForSafe = [\n  1, // Ethereum Mainnet\n  11155111, // Sepolia Testnet\n  42161, // Arbitrum One Mainnet\n  43114, // Avalanche Mainnet\n  8453, // Base Mainnet\n  1313161554, // Aurora Mainnet\n  84532, // Base Sepolia Testnet\n  56, // Binance Smart Chain Mainnet\n  42220, // Celo Mainnet\n  100, // Gnosis Mainnet\n  10, // Optimism Mainnet\n  137, // Polygon Mainnet\n  1101, // Polygon zkEVM Mainnet\n  324, // zkSync Era mainnet\n  534352, // Scroll mainnet\n];\n"],"names":["BaseError","RpcRequestError","constructor","_ref3","body","error","url","super","cause","details","message","metaMessages","stringify","name","Object","defineProperty","this","code","RpcError","_ref","docsPath","shortMessage","ProviderRpcError","options","data","ParseRpcError","InvalidRequestRpcError","MethodNotFoundRpcError","method","arguments","length","undefined","InvalidParamsRpcError","join","InternalRpcError","InvalidInputRpcError","ResourceNotFoundRpcError","ResourceUnavailableRpcError","TransactionRejectedRpcError","MethodNotSupportedRpcError","LimitExceededRpcError","JsonRpcVersionUnsupportedError","UserRejectedRequestError","UnauthorizedProviderError","UnsupportedProviderMethodError","ProviderDisconnectedError","ChainDisconnectedError","SwitchChainError","ADD_ETH_CHAIN_METHOD","defaultShowQrModal","storageKeys","requestedChains","lastUsedChainId","async","connectWC","emitter","walletId","storage","sessionHandler","provider","initProvider","wcOptions","walletConnect","onDisplayUri","walletInfo","getWalletInfo","uri","appUrl","mobile","native","universal","Error","fullUrl","formatWalletConnectUrl","redirect","events","addListener","optionalChains","chainToRequest","chain","chainsToRequestForSafe","map","getCachedChain","includes","rpcMap","requiredChain","chainsToRequest","getChainsToRequest","client","session","connect","pairingTopic","chains","id","setRequestedChainsIds","address","enable","providerChainId","normalizeChainId","chainId","savedParams","saveConnectParamsToStorage","removeListener","onConnect","autoConnectWC","savedConnectParams","getSavedConnectParamsFromStorage","accounts","sessionRequestHandler","isAutoConnect","EthereumProvider","OPTIONAL_EVENTS","OPTIONAL_METHODS","init","showQrModal","projectId","DEFAULT_PROJECT_ID","optionalMethods","optionalEvents","metadata","appMetadata","getDefaultAppMetadata","description","icons","logoUrl","qrModalOptions","disableProviderPing","setMaxListeners","Number","POSITIVE_INFINITY","disconnect","handleSessionRequest","walletLinkToOpen","peer","signer","on","off","createAccount","_address","getAddress","sendTransaction","tx","transactionHash","request","params","gas","numberToHex","value","from","to","signMessage","messageToSign","stringToHex","raw","Uint8Array","uint8ArrayToHex","signTypedData","_data","parseTypedData","domain","primaryType","types","EIP712Domain","getTypesForEIP712Domain","validateTypedData","typedData","serializeTypedData","account","onAccountsChanged","onChainChanged","onDisconnect","removeItem","emit","newAccount","newChainId","newChain","setItem","String","namespaceChains","chainIds","namespaces","NAMESPACE","parseInt","split","getNamespaceChainsIds","namespaceMethods","methods","getNamespaceMethods","apiChain","getChainMetadata","blockExplorerUrls","Set","blockExplorers","x","explorers","chainName","nativeCurrency","rpcUrls","getValidPublicRPCUrl","getItem","JSON","parse","getRequestedChainsIds","push","test","switchChainWC","getRpcUrlForChain","slice","rpc"],"sourceRoot":""}